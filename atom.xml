<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>科学学习与工程笔记</title>
  
  <subtitle>动脑动手</subtitle>
  <link href="https://hanxinle.github.io/atom.xml" rel="self"/>
  
  <link href="https://hanxinle.github.io/"/>
  <updated>2025-12-15T04:56:47.183Z</updated>
  <id>https://hanxinle.github.io/</id>
  
  <author>
    <name>川辣孙悟空(Goku)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>补充 hexo 博客的使用</title>
    <link href="https://hanxinle.github.io/2024/03/29/hexo_slide/"/>
    <id>https://hanxinle.github.io/2024/03/29/hexo_slide/</id>
    <published>2024-03-29T14:59:24.000Z</published>
    <updated>2025-12-15T04:56:47.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件保留与否"><a href="#文件保留与否" class="headerlink" title="文件保留与否"></a>文件保留与否</h1><p>保留_config.yml, themes/, source/, scaffolds/,package.jsona,.gitignore 这些文件夹,其它可以删除。</p><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>提前通过安装包安装好 Git、Node.js，然后执行：</p><p><code>npm install hexo-cli -g</code></p><p><code>npm install</code></p><p><code>npm install hexo-deployer-git --save</code></p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo d</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件保留与否&quot;&gt;&lt;a href=&quot;#文件保留与否&quot; class=&quot;headerlink&quot; title=&quot;文件保留与否&quot;&gt;&lt;/a&gt;文件保留与否&lt;/h1&gt;&lt;p&gt;保留_config.yml, themes/, source/, scaffolds/,package.js</summary>
      
    
    
    
    
    <category term="工具" scheme="https://hanxinle.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>开发环境问题处理</title>
    <link href="https://hanxinle.github.io/2023/12/02/hardware-notes/"/>
    <id>https://hanxinle.github.io/2023/12/02/hardware-notes/</id>
    <published>2023-12-02T06:08:34.000Z</published>
    <updated>2024-02-03T04:31:43.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-一些教训"><a href="#1-一些教训" class="headerlink" title="1 一些教训"></a>1 一些教训</h1><p>非必要不升级系统，导致很多经典软件不能用，最后重新安装系统解决这些问题的.</p><span id="more"></span><h1 id="2-樱桃键盘"><a href="#2-樱桃键盘" class="headerlink" title="2 樱桃键盘"></a>2 樱桃键盘</h1><div class="table-container"><table><thead><tr><th>问题</th><th>按键</th></tr></thead><tbody><tr><td>win 键盘失效</td><td>fn+F9</td></tr><tr><td>F1~F3 与音量强制关联</td><td>fn+Ctrl</td></tr></tbody></table></div><h1 id="3-Git-状态图标异常"><a href="#3-Git-状态图标异常" class="headerlink" title="3 Git 状态图标异常"></a>3 Git 状态图标异常</h1><p><code>WIN+R</code> 启动注册表，找到这一项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers\</span><br></pre></td></tr></table></figure><p>删掉该项下的 <code>Tortoise1Normal</code> 前的所有内容，任务管理器中重启 EXPLORER。</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-一些教训&quot;&gt;&lt;a href=&quot;#1-一些教训&quot; class=&quot;headerlink&quot; title=&quot;1 一些教训&quot;&gt;&lt;/a&gt;1 一些教训&lt;/h1&gt;&lt;p&gt;非必要不升级系统，导致很多经典软件不能用，最后重新安装系统解决这些问题的.&lt;/p&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://hanxinle.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>H.264 总结</title>
    <link href="https://hanxinle.github.io/2023/10/06/h264-concept/"/>
    <id>https://hanxinle.github.io/2023/10/06/h264-concept/</id>
    <published>2023-10-06T11:23:15.000Z</published>
    <updated>2023-11-25T14:17:42.434Z</updated>
    
    <content type="html"><![CDATA[<p><img src="h264_1.png" alt=""></p><p>这个图片是经过概念梳理后做的信息提取说明图，但是理清了 H.264 的内部关系，并且对 H.264 的结构和网络传输的概念予以说明，H.264 的传输说明应该关注的是 RTP 等协议，这些都有专门的 RFC 文档和对应的开源库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;h264_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个图片是经过概念梳理后做的信息提取说明图，但是理清了 H.264 的内部关系，并且对 H.264 的结构和网络传输的概念予以说明，H.264 的传输说明应该关注的是 RTP 等协议，这些都有专门的 </summary>
      
    
    
    
    
    <category term="音视频" scheme="https://hanxinle.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Git 案例</title>
    <link href="https://hanxinle.github.io/2023/07/22/gitsamples/"/>
    <id>https://hanxinle.github.io/2023/07/22/gitsamples/</id>
    <published>2023-07-22T03:29:54.000Z</published>
    <updated>2023-07-23T08:57:49.286Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录记录一些实际操作的案例，可以结合 <a href="https://hanxinle.github.io/2019/09/29/github-note/">GitHub 基本操作教程</a> 在工作中熟悉 Git 的使用。</p><span id="more"></span><h1 id="1-提交前处理冲突"><a href="#1-提交前处理冲突" class="headerlink" title="1 提交前处理冲突"></a>1 提交前处理冲突</h1><p>场景，usr1 和 usr2 协同开发，二人修改了同样的文件，usr1 已经提交，usr2 的操作过程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git add .# 保存更改到本地</span><br><span class="line">git commit -m &quot;&lt;填入修改描述&gt;&quot;# 提交信息，允许 git commit -am &lt;commit-id&gt; 追加新的 git add</span><br><span class="line"># git push will rejected. 提示因为存在冲突，需要先 git pull 合并冲突</span><br><span class="line"></span><br><span class="line">git pull#允许 git pull 操作</span><br><span class="line"></span><br><span class="line">接着去处理冲突文件，比如 Readme.md</span><br><span class="line">&lt;&lt;&lt;&lt;&lt; upstream</span><br><span class="line"></span><br><span class="line">usr1 的内容</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">usr2 的内容，也就是我的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>编辑大小于号之间的内容并且保存，将 <code>&lt;&lt;&lt;&lt;</code>、<code>=====</code>、<code>&gt;&gt;&gt;</code> 这种符号删掉，最终保存的内容就是处理的冲突保存到结果，这个时候可以编译测试。接着：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add Readme.md# 添加冲突文件</span><br><span class="line">git rebase --continue# rebase 看下参考资料</span><br><span class="line">log:</span><br><span class="line">README.md: needs merge</span><br><span class="line">You must edit all merge conflicts and then mark them as resolved using git add</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>参考资料：</p><p>1.<a href="https://juejin.cn/post/6969101234338791432">见”解决冲突CONFLICT“部分</a></p><h1 id="2-更新已有-gitignore"><a href="#2-更新已有-gitignore" class="headerlink" title="2 更新已有 .gitignore"></a>2 更新已有 .gitignore</h1><p>更新已经在 repo 中的 .gitignore 文件，比如添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">bin/*</span><br></pre></td></tr></table></figure><p>保存文件，之前追踪的 bin 文件夹及其内部内容，在本地立刻就不会被追踪，这个通过 git status 即可发现。即，允许不提交 .gitignore 的方式使得本地追踪生效。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录记录一些实际操作的案例，可以结合 &lt;a href=&quot;https://hanxinle.github.io/2019/09/29/github-note/&quot;&gt;GitHub 基本操作教程&lt;/a&gt; 在工作中熟悉 Git 的使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://hanxinle.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Git" scheme="https://hanxinle.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C/C++ 技术随笔</title>
    <link href="https://hanxinle.github.io/2023/07/09/cpp-skill/"/>
    <id>https://hanxinle.github.io/2023/07/09/cpp-skill/</id>
    <published>2023-07-09T14:10:37.000Z</published>
    <updated>2023-07-22T04:14:41.761Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>单例模式的目的是确保唯一实例，确切的说是为了在应用程序的进程空间中确保唯一实例，刚刚在视频处理器的使用中被这种设计小小震撼一下：</p><span id="more"></span></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Single &#123;</span><br><span class="line">public:</span><br><span class="line">    static Single *Get() &#123;</span><br><span class="line">        static Single re;</span><br><span class="line">        return &amp;re;</span><br><span class="line">    &#125;</span><br><span class="line">    void Set(int x, int y) &#123;</span><br><span class="line">        a = x;</span><br><span class="line">        b = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Print() &#123; std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int a = 0;</span><br><span class="line">    int b = 0;</span><br><span class="line">    Single() &#123;&#125;</span><br><span class="line">    Single(const Single &amp;) &#123;&#125;</span><br><span class="line">    Single &amp;operator=(const Single &amp;) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto s = Single::Get();</span><br><span class="line">    s-&gt;Set(12, 13);</span><br><span class="line">    s-&gt;Get()-&gt;Print();</span><br><span class="line">    std::thread([]() &#123;</span><br><span class="line">        auto sa = Single::Get();</span><br><span class="line">        sa-&gt;Set(01, 3);</span><br><span class="line">           &#125;).join();</span><br><span class="line">    s-&gt;Get()-&gt;Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">12 13</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单例模式的目的是确保唯一实例，确切的说是为了在应用程序的进程空间中确保唯一实例，刚刚在视频处理器的使用中被这种设计小小震撼一下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://hanxinle.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>使用 OBS 开发零散记录</title>
    <link href="https://hanxinle.github.io/2023/07/04/obs-src-dev/"/>
    <id>https://hanxinle.github.io/2023/07/04/obs-src-dev/</id>
    <published>2023-07-04T01:52:56.000Z</published>
    <updated>2023-07-04T13:57:58.230Z</updated>
    
    <content type="html"><![CDATA[<p>这个笔记比较乱，记录下 OBS 源码分析和使用 OBS 开发的一些做法。</p><span id="more"></span><h1 id="我对源码修改的地方："><a href="#我对源码修改的地方：" class="headerlink" title="我对源码修改的地方："></a>我对源码修改的地方：</h1><ol><li>I:\007_webrtc_ffmpeg_opencv_obs\obs_2019\obs-studio\plugins\win-capture\window-capture.c</li></ol><p>line 407, 最小化处理，原代码注释掉了。</p><ol><li>I:\007_webrtc_ffmpeg_opencv_obs\obs_2019\obs-studio\libobs\obs-windows.c</li></ol><p>将三处 data、plugin 的加载路径由上层改为本地。</p><h1 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h1><p><img src="image-20230701181056276.png" alt="image-20230701181056276"></p><p>代码的四大块，其中 frontend 是页面。</p><p><img src="image-20230701181903678.png" alt="image-20230701181903678"></p><p>主界面：OBSBasic.ui，</p><p>F10，调试模式进入到 main 函数，解决方案里面搜 main( 不管用。</p><p>I:\007_webrtc_ffmpeg_opencv_obs\obs_2019\obs-studio\UI\obs-app.cpp</p><p>line: 2126 中，找到初始化语句 <em>program.OBSInit()</em>，在这个函数中，有条语句是：</p><p><em>qRegisterMetaType<VoidFunc>()</em>，使用的信号不是基本信号的时候，要记得对信号进行注册，不然信号发不过去。</p><p>继续跟踪函数，会看到追踪至 StartupOBS，内部有 obs_stratup，这个函数查看声明，前缀带有 EXPORT，说明是有库将其导出的，因此在后续的开发中，我们可以只调用这个函数开发就可以了。</p><p>初始化中需要初始化音视频，创建基本界面，还会检查更新等，对我们来说关心的就是初始化音频和视频。</p><p>obs 中加载插件的方式是 Loadlibray 和 GetProcAddress ，即加载库然后获取函数的名字再使用，程序销毁的时候做 Free 操作。还是再 OBSInit 中查看这些信息。</p><p>obs_load_modules() ;</p><p>音频设置 </p><p>ResetAudio</p><p><img src="image-20230701224233845.png" alt="image-20230701224233845"></p><p><img src="image-20230701224142137.png" alt="image-20230701224142137"></p><p><img src="image-20230701225306546.png" alt="image-20230701225306546"></p><p>obs_reset_audio () 后续会用到这个库，是 libobs 导出的.</p><p>obs_init_audio () </p><p>视频设置</p><p>ResetVideo</p><p>AttemptToResetVideo</p><p>obs_reset_video</p><p>obs_init_video</p><p>obs 根对象</p><p>struct obs_core * obs = NULL; 整个工程的功能都依赖这个对象，比如音视频帧的获取等等。</p><p>创建图像线程 obs_graphices_thread 预览功能。</p><p>os_semaphore 是信号量相关，再video-io.c 中，点击录制会进入到其中执行有关逻辑。</p><p>ResetOutputs（） 设置输出对象—-obs_output_create—录制相关，mux 复用器, 属于 ffmpeg 的复用。</p><p>点击录制就会还会计进入 obs-ffmpeg-mux.c 中 ffmpeg_mux_start (void * data) 开始的</p><h1 id="从录制开始"><a href="#从录制开始" class="headerlink" title="从录制开始"></a>从录制开始</h1><p>recordButton 以及槽函数 on_recordButton_clicked</p><p>obs_output_start、obs_output_stop 是以后我们会学习使用的两种不同的流程。</p><p>声音的采集需要有混音操作，可能比画面录制更复杂。</p><p>窗口采集用 bitblt 只能采集有窗口句柄的窗口，无句柄的用 wgc,例如谷歌浏览器或者 vscode ，继续使用 bitblt 会出现黑屏。</p><p>显示器采集源码在 duplicator-monitor-capture.c </p><p>bitblt x264 采集源码的详细分析</p><p>点击开始录制按钮后发生了什么？</p><p>什么时候开始编码？</p><p>视频帧是怎么存储？</p><p>环形队列 circleBuffer 的方式.</p><p>4个线程</p><p>video_thread ：录制编码</p><p>obs_graphics_thread 预览、采集</p><p>audio_thread 音频输出</p><p>CaptureThread 音频采集线程</p><p>raw_frame 是信号量，</p><p>os_sem_post os_sem_wait</p><p>大项目记得看堆栈</p><p>Load(savePath) 进入 win-wasapi 是音频采集相关的项目，</p><p>osb-source.c 中有处理多路音频的数据，要比视频处理复杂。</p><h1 id="开始移植工程"><a href="#开始移植工程" class="headerlink" title="开始移植工程"></a>开始移植工程</h1><p>学到了一个技巧，</p><p>点击要查看的函数下断点，当执行到这里的时候，就可以看到程序填入的实际值，那么自己移植程序的时候，就可以将值直接填入然后继续移植工作，不需要再去代码中查找。</p><p>带界面的窗口出问题记得使用 exit(0);</p><p>obs 要先创建场景再创建源，然后才能使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个笔记比较乱，记录下 OBS 源码分析和使用 OBS 开发的一些做法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OBS" scheme="https://hanxinle.github.io/tags/OBS/"/>
    
  </entry>
  
  <entry>
    <title>OBS 编译记录</title>
    <link href="https://hanxinle.github.io/2023/06/29/obs-build/"/>
    <id>https://hanxinle.github.io/2023/06/29/obs-build/</id>
    <published>2023-06-29T12:39:15.000Z</published>
    <updated>2023-06-30T12:18:27.766Z</updated>
    
    <content type="html"><![CDATA[<p>OBS 的编译还是有陷阱的，这次编译出来留一个文档。</p><span id="more"></span><p>还是用以前下载的源码和依赖尝试编译，昨天晚上在这里搞了很久，今天上午发现了问题并且解决了问题，以下是记录。</p><h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><p><a href="https://github.com/obsproject/obs-studio/wiki/Build-Instructions-For-Windows">https://github.com/obsproject/obs-studio/wiki/Build-Instructions-For-Windows</a></p><h1 id="2-系统说明"><a href="#2-系统说明" class="headerlink" title="2 系统说明"></a>2 系统说明</h1><div class="table-container"><table><thead><tr><th>类目</th><th>信息</th></tr></thead><tbody><tr><td>源码</td><td>2019版</td></tr><tr><td>编译工具</td><td>vs2019</td></tr><tr><td>DepsPath</td><td>I:/obs_2019/dependencies2019/win32/include</td></tr><tr><td>QTDIR</td><td>C:/Qt/Qt5.14.2/5.14.2/msvc2017</td></tr><tr><td>ENABLE_UI</td><td>勾选</td></tr><tr><td>BUILD_BROWSER</td><td>不要勾选 （默认勾选的，要取消掉）</td></tr></tbody></table></div><h1 id="3-编译过程的坑"><a href="#3-编译过程的坑" class="headerlink" title="3 编译过程的坑"></a>3 编译过程的坑</h1><ol><li>如果系统中曾经配置了 prebuild 的 FFmpeg 并且添加到环境变量 Path 中，会导致编译过程中找不到 FFmpeg 相关的库，导致编译出现错误；</li><li>编译过程中记得去系统环境变量中找 Python 相关的环境 Anaconda，将它们全部删掉，我开始采用在其值后面添加 —— 字符的方式注释掉，发现还是会对编译有干扰。后续我卸载了 Anaconda 并且删除掉这些环境变量。</li><li>编译过 WebRTC 的话会配置 depot_tools ，里面也有 Python 开发环境，记得在 Path 中删除。</li><li>以前安装在 C:/Python27 我没有删除，但在 Path 中删掉了这个值。</li></ol><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>没有这些陷阱，按照网上提供的编译帮助编译就可以了， 使用 cmake，注意 cmake 和  Visual Studio 的版本要求。生成工程后打开，按 F7 生成解决方案。</p><p>生成的路径是 <strong>&lt;盘符&gt;:\obs_2019\obs-studio\build_2019\rundir\Debug\bin\32bit</strong></p><p>生成成功不能运行的话，右击 INSTALL - 仅用于项目 - 仅生成 INSTALL ，可在配置的 安装目录中发现软件，可进入 bin 路径启动验证功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;OBS 的编译还是有陷阱的，这次编译出来留一个文档。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OBS" scheme="https://hanxinle.github.io/tags/OBS/"/>
    
  </entry>
  
  <entry>
    <title>C++ 特性之 promise/future 示例</title>
    <link href="https://hanxinle.github.io/2023/06/27/promise-future/"/>
    <id>https://hanxinle.github.io/2023/06/27/promise-future/</id>
    <published>2023-06-27T11:26:49.000Z</published>
    <updated>2023-06-27T11:36:07.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://en.cppreference.com/w/cpp/thread/promise">https://en.cppreference.com/w/cpp/thread/promise</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天面试问到一个 C++ 一个异步转为同步的特性，</p><span id="more"></span><p>C++ 中可以通过 std::future 和 std::promise 实现同步。基本思路是:</p><ol><li>使用 std::promise 生成一个 promise 对象,该对象可在未来生成一个值或抛出异常。</li><li>调用 promise 对象的 get_future 方法获取对应的 future 对象。该 future 对象可以获取 promise 对象设置的value或exception。</li><li>promise 对象传递给设置值或抛出异常的线程。</li><li>线程通过调用 future 对象的 get 方法来获取值或异常,该调用会阻塞直到 promise 对象设置为止。</li><li>设置值或抛出异常的线程通过 promise 对象的 set_value 或 set_exception 来设置结果。</li><li>get 方法获取结果后解除阻塞,主线程继续执行。这样,通过 future/promise,我们可以实现两个线程之间同步的值传递,主线程将阻塞等待结果。</li></ol><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">doSomeWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;prom]() &#123;</span><br><span class="line">        prom.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// 设置结果</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> result = fut.<span class="built_in">get</span>(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">doSomeWork</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2（来自参考文献）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accumulate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;<span class="type">int</span>&gt;::iterator first, std::vector&lt;<span class="type">int</span>&gt;::iterator last, std::promise&lt;<span class="type">int</span>&gt; accumulate_promise)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(first, last, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1 accumulate running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    accumulate_promise.<span class="built_in">set_value</span>(sum); <span class="comment">// Notify future</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(std::promise&lt;<span class="type">double</span>&gt; barrier)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5 thread do_work running   barrier.set_value().&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    barrier.<span class="built_in">set_value</span>(<span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Demonstrate using promise&lt;int&gt; to transmit a result between threads.</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; accumulate_promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; accumulate_future = accumulate_promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">work_thread</span><span class="params">(accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// future::get() will wait until the future has a valid result and retrieves it.</span></span><br><span class="line">    <span class="comment">// Calling wait() before get() is not needed</span></span><br><span class="line">    <span class="comment">// accumulate_future.wait();  // wait for result</span></span><br><span class="line">    accumulate_future.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2 result=&quot;</span> &lt;&lt; accumulate_future.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    work_thread.<span class="built_in">join</span>(); <span class="comment">// wait for thread completion</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstrate using promise&lt;void&gt; to signal state between threads.</span></span><br><span class="line">    std::promise&lt;<span class="type">double</span>&gt; barrier;</span><br><span class="line">    std::future&lt;<span class="type">double</span>&gt; barrier_future = barrier.<span class="built_in">get_future</span>();</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;3 before running thread do work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">new_work_thread</span><span class="params">(do_work, std::move(barrier))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4 after unning thread do work.   barrier_future.wait(); &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    barrier_future.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;6 double = &quot;</span> &lt;&lt; barrier_future.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    new_work_thread.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;7 after join.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/thread/promise&quot;&gt;https://en.cppreference.com/w/cpp/thread/promise&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;今天面试问到一个 C++ 一个异步转为同步的特性，&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://hanxinle.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu/Winodws 开发环境打点备忘</title>
    <link href="https://hanxinle.github.io/2023/06/19/ubuntu-tools/"/>
    <id>https://hanxinle.github.io/2023/06/19/ubuntu-tools/</id>
    <published>2023-06-19T08:59:15.000Z</published>
    <updated>2023-06-20T13:32:54.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>之前写过 vim 的教程，还写过 emacs 使用教程，自己整理了一份 emacs.d 文件，每次装机了就拿出来。</p><p>这一次是配置共享文件，这个不仅可以用于虚拟机，也可以用于 Windows 系统与远程开发机同步文件，并且方便在本地使用一些编码工具。</p><span id="more"></span><p>刚刚在 ip 地址是 192.168.0.3 的 vmware pro 虚拟机搭建成功了，暂时告别 vmware 自带的共享文件夹了，因为共享文件夹的权限问题，有些文件编译不成功，所以想到用 samba服务，在上家公司工作的时候，需要帮着嵌入式部门解决问题，这个服务其实也没有配置成功，真的是蛋疼，工作效率别提多低了。</p><h1 id="2-Samba-安装步骤"><a href="#2-Samba-安装步骤" class="headerlink" title="2 Samba 安装步骤"></a>2 Samba 安装步骤</h1><ol><li><p>执行命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba</span><br></pre></td></tr></table></figure></li><li><p>编辑 /etc/smb.conf，跳到文件尾部，插入如下内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[smb_share] # 会在共享中显示的名字</span><br><span class="line">comment = share</span><br><span class="line">path = /home/hanxinle/smb_share # 绝对路径，记得去创建文件夹</span><br><span class="line">writable = yes</span><br><span class="line">browseable = yes</span><br></pre></td></tr></table></figure></li><li><p>创建 smba 用户，按照提示出入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a hanxinle</span><br></pre></td></tr></table></figure></li><li><p>重启服务，实际上我是先重启后，无法使用服务才根据资料创建的 smba 用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/smbd restart</span><br><span class="line">sudo /etc/init.d/nmbd restart</span><br><span class="line">systemctl restart smb</span><br></pre></td></tr></table></figure></li><li><p>Winodws 文件夹中输入 \192.168.0.103，会弹出名为 smb_share 的网络资源，打开后进入，这一步骤可能要输入用户名和密码。</p></li><li><p>可以下一次输入 \\ip 后，右击网络资源，选择映射到本地磁盘，选择一个没有使用的盘符，进入后编辑的文件会自动同步到 Ubuntu 系统.</p></li></ol><h1 id="3-Windows-按照域名访问-vmware-虚拟机"><a href="#3-Windows-按照域名访问-vmware-虚拟机" class="headerlink" title="3 Windows 按照域名访问 vmware 虚拟机"></a>3 Windows 按照域名访问 vmware 虚拟机</h1><p>首先，VM 中的 Ubuntu 以 root 权限编辑 /etc/hosts 文件，假设虚拟机 ip 是 192.168.0.103 则添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.103   rtc.com</span><br></pre></td></tr></table></figure><p>在 Windows 10 中找到路径 <em>C:\Windows\System32\drivers\etc</em>，以管理员身份打开该路径中的 <em>hosts</em> 文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.103   rtc.com</span><br></pre></td></tr></table></figure><p>Windows 10 中执行 ping 命令即可验证。</p><h1 id="4-Windows-系统局域网传输文件"><a href="#4-Windows-系统局域网传输文件" class="headerlink" title="4 Windows 系统局域网传输文件"></a>4 Windows 系统局域网传输文件</h1><p>将要分享的文件放入文件夹，然后将该文件夹分享给 Everyone，另一台 Windows 中 <em>WIN+R</em> 后执行 \\<pc1的ip>，即可访问分享的文件夹，和配置 samba 并访问相似。 </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h1&gt;&lt;p&gt;之前写过 vim 的教程，还写过 emacs 使用教程，自己整理了一份 emacs.d 文件，每次装机了就拿出来。&lt;/p&gt;
&lt;p&gt;这一次是配置共享文件，这个不仅可以用于虚拟机，也可以用于 Windows 系统与远程开发机同步文件，并且方便在本地使用一些编码工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://hanxinle.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>C++和lua混合程序设计</title>
    <link href="https://hanxinle.github.io/2023/03/14/lua-cpp/"/>
    <id>https://hanxinle.github.io/2023/03/14/lua-cpp/</id>
    <published>2023-03-14T09:00:18.000Z</published>
    <updated>2023-10-04T00:46:30.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="库编译"><a href="#库编译" class="headerlink" title="库编译"></a>库编译</h2><p>从官网下载的版本是 5.1.4 ，配合《lua设计与实现》在 Linux/Windows 编译，在 Windows 上编译的过程中<span id="more"></span> 有些小坑，记录下这些，以后不用再话费时间重复劳动了。</p><p>vs2019 新建 dll 项目，将 src 路径下所有文件拷贝到工程路径并添加到解决方案，并在工程路径上一级目录新建 bin、lib 两个文件夹，用于输出生成的 dll 和 lib 文件，不适用预编译头 .pch 文件。</p><p>实验发现编译工程会生成 dll 文件，但是无 lib 文件生成，在 luaconf.h 文件  154 行发现说明，需要在工程添加 宏定义 <em>LUA_BUILD_AS_DLL</em>。</p><p>将“属性-链接器-高级-导入库”，设置为 <em>..\lib$(TargetName).lib</em>，再次编译程序即可。</p><h2 id="测试工程"><a href="#测试工程" class="headerlink" title="测试工程"></a>测试工程</h2><p>新建控制台程序，需要以 extern “C” 包含的文件及引入工程的文件如下：</p><p>{lauxlib}.h/.c、{lua}.h/.c、lualib.h、luaconf.h，注释掉 lua.c 中的 main 函数，新建 main.lua 文件，代码就一条 <code>print (&quot;hello world.&quot;)</code>，记得新工程导入 dll 和 lib 文件,该工程的 main.cpp 如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lua_State *lua = <span class="built_in">lua_open</span>();</span><br><span class="line">    <span class="built_in">luaopen_base</span>(lua);</span><br><span class="line">    <span class="built_in">luaopen_table</span>(lua);</span><br><span class="line">    <span class="built_in">luaL_openlibs</span>(lua);</span><br><span class="line">    <span class="built_in">luaopen_string</span>(lua);</span><br><span class="line">    <span class="built_in">luaopen_math</span>(lua);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">luaL_loadfile</span>(lua, <span class="string">&quot;main.lua&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *error = <span class="built_in">lua_tostring</span>(lua, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n ִrun script file failed.&quot;</span>, error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lua_pcall</span>(lua, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *error = <span class="built_in">lua_tostring</span>(lua, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n ִrun script file failed.&quot;</span>, error);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;h2 id=&quot;库编译&quot;&gt;&lt;a href=&quot;#库编译&quot; class=&quot;headerlink&quot; title=&quot;库编译&quot;&gt;&lt;/a&gt;库编译&lt;/h2&gt;&lt;p&gt;从官网下载的版本是 5.1.4 ，配合《lua设计与实现》在 Linux/Windows 编译，在 Windows 上编译的过程中</summary>
    
    
    
    
    <category term="工具" scheme="https://hanxinle.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>SICP 相关</title>
    <link href="https://hanxinle.github.io/2023/02/23/sicp/"/>
    <id>https://hanxinle.github.io/2023/02/23/sicp/</id>
    <published>2023-02-23T02:00:37.000Z</published>
    <updated>2023-02-23T02:27:00.375Z</updated>
    
    <content type="html"><![CDATA[<p>首先进行环境安装，其次记录重要信息提示。</p><span id="more"></span><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="Ubuntu-下安装-MIT-Scheme"><a href="#Ubuntu-下安装-MIT-Scheme" class="headerlink" title="Ubuntu 下安装 MIT-Scheme"></a>Ubuntu 下安装 MIT-Scheme</h2><p>下载链接是：</p><p>这个软件当前不再支持 Windows ，需要在类 Linux 环境运行。</p><h2 id="DrRacket-sicp-package"><a href="#DrRacket-sicp-package" class="headerlink" title="DrRacket+sicp package"></a>DrRacket+sicp package</h2><p> 打开 DrRacket ，依次点击菜单 “File” - “Install Package”，输入 <strong>sicp</strong>，等待几分钟，可能需要网络加速器提高下载速度.</p><p>安装结束后，可以在工作区域输入</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#lang sicp</span><br><span class="line">(<span class="name">inc</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>安装两个插件，分别是 Magic Racket 和 AyaSEditor，后者是格式化插件，前者是用于编译运行的插件（前提还是 DrRacket 要安装好 sicp package），安装 MR 插件后要在这个插件的设置中，将 Racket.exe 的完整路径添加到 <em>Racket Path</em> 中，默认的位置是 <em>C:\Program Files\Racket\Racket.exe</em> 。</p><p>测试安装效果，新建文件 hello_sicp.rkt，代码如下</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#lang sicp</span><br><span class="line">(<span class="name"><span class="built_in">+</span></span> <span class="number">12</span> <span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>点击右上角Load File 按钮或者 Run File 按钮，命令行页面会输出 24，表示安装成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先进行环境安装，其次记录重要信息提示。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Lisp/Scheme" scheme="https://hanxinle.github.io/tags/Lisp-Scheme/"/>
    
  </entry>
  
  <entry>
    <title>Qt 开发随笔，不断更新ing</title>
    <link href="https://hanxinle.github.io/2023/01/27/qt-tips/"/>
    <id>https://hanxinle.github.io/2023/01/27/qt-tips/</id>
    <published>2023-01-27T12:31:02.000Z</published>
    <updated>2023-07-07T14:03:01.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>文章记录一些开发时候遇到的问题和解决方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>Qt Assistant（安装 Qt 时候选择安装，用于文档查询）<span id="more"></span></li></ol><h1 id="问题和解决方法"><a href="#问题和解决方法" class="headerlink" title="问题和解决方法"></a>问题和解决方法</h1><ol><li><p>Qt Design 设计的控件，编译工程后进行代码设计，代码补全方面不能正确识别控件对象。<br>解：VS2019 菜单栏选择“项目”-“重定目标解决方案”，接着菜单栏选择“项目”-“重新扫描解决方案”，后续只进行第 2 种操作即可在输入 ui 的时候自动列出 ui 持有的控件对象名。</p></li><li><p>如何添加图片文件，供 QIcon 或者 QImage 加载，像 vs 一样提供代码所在路径 “./1.png” 不成功。<br>解：新建资源文件，先添加 Prefix，填好后再向其中添加文件，文件是 picture 路径下的若干文件，代码中使用的路径值为 “:/imgs/picture/1.jpg” 及其它，代替 “./1.jpg”.</p></li><li><p>Clion 创建 Qt 工程无法编译的问题.</p><p>创建 Qt 工程时候可以指明 Qt CMake prefix path，如果这一步自己忘了做，那么在 <em>CMakeLists.txt</em> 中可以添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_PREFIX_PATH &quot;C:/Qt/Qt5.14.2/5.14.2/msvc2017&quot; )</span><br></pre></td></tr></table></figure><p>，这个时候依旧是编译不过的。在 “File-Setting-build,Execution,Deployment-CMake” 的 CMake options 中添加 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DCMAKE_PREFIX_PATH=C:/Qt/Qt5.14.2/5.14.2/msvc2017</span><br></pre></td></tr></table></figure><p>保存设置。项目代码可以编译运行了。</p><p>参考文献点击<a href="https://www.cnblogs.com/citrus/p/15926004.html">这个链接</a>。</p></li><li><p>Qt 工程添加 .ui 文件使其生效的方法</p><p>选择了工程，选择添加新项，在 Qt 类目下，最简单的方法是选择添加 <em>Qt Widgets Class</em>，这样添加后即包括了 .ui 文件，还包括了 .h 和 .cpp 文件。如果单独添加了 ui 文件，那么在编辑这个 ui 文件后使其生效的方法是使用 uic 命令，比如添加了 login.ui ，可以运行如下命令生成 ui_login 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uic login.ui -o ui_login.h</span><br></pre></td></tr></table></figure><p>然后在工程中添加类，同时会添加两个文件 logoin.h 和 login.cpp ，基类选择 QWidiget，login.h 头文件记得包含 ui_login.h 和 QWidget 文件，最后在 main 中生成 login 对象，调用 show 即可看到效果。</p><p>但是每次修改 login.ui 文件，都需要调用 uic 命令，为了方便编译，选择<strong>工程- 属性-生成事件-生成前事件</strong> 中命令行添加 <em>uic login.ui -o ui_login.h</em>就好。</p></li></ol><p>   刚刚测试了升级窗口部件，原来是设置后点击提升才有效果，接下来就可以在工程中添加刚刚设置的类，记得设置 Q_OBJECT 以及构造函数的编写，如果忘了写父类相关信息，会造成不显示等问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;文章记录一些开发时候遇到的问题和解决方法。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Qt Assistant（安装 Qt 时候选择安装，用于文档查询）</summary>
    
    
    
    
    <category term="Qt" scheme="https://hanxinle.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>状态模式实现与内存泄漏问题解决</title>
    <link href="https://hanxinle.github.io/2023/01/14/state-design-pattern-and-memory-leak/"/>
    <id>https://hanxinle.github.io/2023/01/14/state-design-pattern-and-memory-leak/</id>
    <published>2023-01-14T06:33:51.000Z</published>
    <updated>2023-01-20T08:04:17.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><h2 id="1-1-写作背景"><a href="#1-1-写作背景" class="headerlink" title="1.1 写作背景"></a>1.1 写作背景</h2><p>我看的设计模式资料使用 C# 和 Java 实现，这两种语言不需要处理内存泄漏问题。后续发现按照资料仿写的 C++ 代码有内存泄漏的情况，于是尝试解决这个问题，对 C++ 有新的理解，故记录之。<span id="more"></span></p><h2 id="1-2-参考资料"><a href="#1-2-参考资料" class="headerlink" title="1.2 参考资料"></a>1.2 参考资料</h2><ol><li><a href="https://github.com/jaredtao/DesignPattern/tree/master/code/Behavior/State">本文参考的单例模式写法</a></li><li><a href="https://github.com/JakubVojvoda/design-patterns-cpp/blob/master/state/State.cpp">补充实现</a></li><li><a href="https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/State">两种状态模式实现，第二种与资料1类似</a></li><li>书籍-大话设计模式</li><li>headfirst设计模式</li><li>经典设计模式黑皮书.</li><li><a href="https://github.com/Apress/design-patterns-in-modern-cpp">source code of Design Patterns in Modern cpp</a></li><li><a href="https://kinddragon.github.io/vld/">Visual Leak Detector</a></li></ol><h1 id="２-问题的发现与检测"><a href="#２-问题的发现与检测" class="headerlink" title="２ 问题的发现与检测"></a>２ 问题的发现与检测</h1><h2 id="2-1-发现和分析问题"><a href="#2-1-发现和分析问题" class="headerlink" title="2.1 发现和分析问题"></a>2.1 发现和分析问题</h2><p>状态模式有个特点，即调用者调用状态A下的func1，其状态可<strong>自动</strong>切换为状态B，我在第一版的实现时重点在实现原型（从 Java / C# 翻译代码），<br>状态改变的代码是如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Class User;</span><br><span class="line">class IState()&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual func(Context * ctx) = 0;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">class State1:public IState &#123;</span><br><span class="line">public:</span><br><span class="line">    func(Context * ctx) &#123;</span><br><span class="line">        // some ops</span><br><span class="line">        ctx-&gt;setState(new State2);   //leak</span><br><span class="line">     &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">class State2:public IState &#123;</span><br><span class="line">public:</span><br><span class="line">    func(Context * ctx) &#123;</span><br><span class="line">        // some ops</span><br><span class="line">        ctx-&gt;setState(new State1);   //leak</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">Class User &#123;</span><br><span class="line">public:</span><br><span class="line">    IState * stt_;</span><br><span class="line">    void setState(ISate * p) &#123;</span><br><span class="line">        if (nullptr != stt_)&#123;</span><br><span class="line">            delete stt_;</span><br><span class="line">            stt_ = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// this param cause mem link</span><br><span class="line">ctx-&gt;setState(new State1());</span><br></pre></td></tr></table></figure><h2 id="2-2-检测问题"><a href="#2-2-检测问题" class="headerlink" title="2.2 检测问题"></a>2.2 检测问题</h2><p>上述实现，在切装状态的调用时，其会 new 个新对象，而没有释放，我尝试过在函数内部每次 new 对象传入函数，然后 delete 它，不出意外程序错误。检查内存泄漏的手段是在 vs2019 下实施的，样本代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define _CRTDBG_MAP_ALLOC</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;crtdbg.h&gt;</span><br><span class="line">// include other files.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)  &#123;</span><br><span class="line"></span><br><span class="line">    // my test code here.</span><br><span class="line">    // init User * pu;</span><br><span class="line">    // cause mem-leak.</span><br><span class="line">    pu-&gt;setState(new sa);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _CrtDumpMemoryLeaks();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>更新信息：写完初稿后不久，我开始使用 vld，其介绍和安装信息见参考资料 8，工具已经上传到 GitHub 仓库内，可以按照一般的添加库方法在 vs2019 内配置和使用，记得将 bin 路径下所有文件拷贝到 Debug 路径（.exe 所在路径），配置文件.ini 文件也可以一并拷贝，</p><h1 id="3-使用单例模式"><a href="#3-使用单例模式" class="headerlink" title="3 使用单例模式"></a>3 使用单例模式</h1><p>这种写法是改变传入 setState 的对象指针的生成方法，在状态模式中，每种状态的紧紧需要该状态的一个实例即可表示当前主体所处于的状态，考虑引入单例模式，并且在引入的单例模式中，使用静态变量的写法如下，这段代码后面的篇幅再补充另一种单例写法并且阐述一些线程安全的问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#define _CRTDBG_MAP_ALLOC</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;crtdbg.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class User;</span><br><span class="line"></span><br><span class="line">class base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func1(User *u) = 0;</span><br><span class="line">    virtual void func2(User *u) = 0;</span><br><span class="line">    virtual ~base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class sa : public base &#123;</span><br><span class="line">public:</span><br><span class="line">   </span><br><span class="line">    static sa &amp;getInstance() &#123;</span><br><span class="line">        static sa r;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void func1(User *u);</span><br><span class="line">    void func2(User *u);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    sa() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class sb : public base &#123;</span><br><span class="line">public: </span><br><span class="line">    static sb &amp;getInstance() &#123;</span><br><span class="line">        static sb r;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void func1(User *u);</span><br><span class="line">    void func2(User *u);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    sb() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">public:</span><br><span class="line">    User() &#123; p_ = nullptr; &#125;</span><br><span class="line">    base *p_; // ok</span><br><span class="line">    void setState(base *p) &#123; p_ = p; &#125;</span><br><span class="line">    void func1() &#123; p_-&gt;func1(this); &#125;</span><br><span class="line"></span><br><span class="line">    void func2() &#123; p_-&gt;func2(this); &#125;</span><br><span class="line"></span><br><span class="line">    ~User() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sa::func1(User *u) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sa::func1&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    u-&gt;setState(&amp;sb::getInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sb::func1(User *u) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sb::func1&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    u-&gt;setState(&amp;sa::getInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sa::func2(User *u) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sa::func2&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    u-&gt;setState(&amp;sb::getInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sb::func2(User *u) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sb::func2&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    u-&gt;setState(&amp;sa::getInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    shared_ptr&lt;User&gt; pu = make_shared&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">    pu-&gt;setState(&amp;sa::getInstance());</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (i % 2 == 0) &#123;</span><br><span class="line">            pu-&gt;setState(&amp;sb::getInstance());</span><br><span class="line">            pu-&gt;func2();</span><br><span class="line">            pu-&gt;func1();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pu-&gt;setState(&amp;sa::getInstance());</span><br><span class="line">            pu-&gt;func1();</span><br><span class="line">            pu-&gt;func2();</span><br><span class="line">        &#125;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(1));</span><br><span class="line">    &#125;</span><br><span class="line">    pu.reset();</span><br><span class="line">    cout &lt;&lt; &quot;test done.&quot; &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    _CrtDumpMemoryLeaks();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码还可以将 getInstance 函数重新实现为返回指针的形式，这样 setState 可以传入参数 sa::getInstance() 的形式，下面代码只包含核心的写法和用法，不包含main函数。单例模式有线程安全的问题需要考量，在这里不再论述。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class sa : public base &#123;</span><br><span class="line">public:</span><br><span class="line">    static sa *getInstance() &#123;</span><br><span class="line">        if (pa_ == nullptr) &#123;</span><br><span class="line">            return new sa;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return pa_;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    static sa* pa_;</span><br><span class="line">    sa()&#123; pa_ = nullptr;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">sa * sa::pa_ = nullptr; </span><br><span class="line">// .....</span><br><span class="line">    puser-&gt;setState(sa::getInstance());</span><br><span class="line">// .....</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="4-使用智能指针"><a href="#4-使用智能指针" class="headerlink" title="4 使用智能指针"></a>4 使用智能指针</h1><p>写法变为 User 拥有了 share_ptr<IState> 变量替换原始指针，在 setState 中，参数传入派生类指针，写法是make_shared<Inherited Class>().下面是可运行的测试代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#define _CRTDBG_MAP_ALLOC</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;crtdbg.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class User;</span><br><span class="line"></span><br><span class="line">class base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func1(User *u) = 0;</span><br><span class="line">    virtual void func2(User *u) = 0;</span><br><span class="line">    virtual ~base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class sa : public base &#123;</span><br><span class="line">public:</span><br><span class="line">    sa() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    void func1(User *u);</span><br><span class="line">    void func2(User *u);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class sb : public base &#123;</span><br><span class="line">public:</span><br><span class="line">    sb() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    void func1(User *u);</span><br><span class="line">    void func2(User *u);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">public:</span><br><span class="line">    User() &#123; p_ = nullptr; &#125;</span><br><span class="line">    shared_ptr&lt;base&gt; p_;</span><br><span class="line">    void setState(shared_ptr&lt;base&gt; p) &#123; p_ = p; &#125;</span><br><span class="line"></span><br><span class="line">    void func1() &#123; p_-&gt;func1(this); &#125;</span><br><span class="line">    void func2() &#123; p_-&gt;func2(this); &#125;</span><br><span class="line"></span><br><span class="line">    ~User() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sa::func1(User *u) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sa::func1&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    u-&gt;setState(make_shared&lt;sb&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sb::func1(User *u) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sb::func1&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    u-&gt;setState(make_shared&lt;sa&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sa::func2(User *u) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sa::func2&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    u-&gt;setState(make_shared&lt;sb&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sb::func2(User *u) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sb::func2&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    u-&gt;setState(make_shared&lt;sa&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    shared_ptr&lt;User&gt; pu = make_shared&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">    pu-&gt;setState(make_shared&lt;sa&gt;());</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (i % 2 == 0) &#123;</span><br><span class="line">            pu-&gt;setState(make_shared&lt;sb&gt;());</span><br><span class="line">            pu-&gt;func2();</span><br><span class="line">            pu-&gt;func1();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pu-&gt;setState(make_shared&lt;sa&gt;());</span><br><span class="line">            pu-&gt;func1();</span><br><span class="line">            pu-&gt;func2();</span><br><span class="line">        &#125;</span><br><span class="line">        this_thread::sleep_for(chrono::seconds(1));</span><br><span class="line">    &#125;</span><br><span class="line">    pu.reset();</span><br><span class="line">    cout &lt;&lt; &quot;test done.&quot; &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    _CrtDumpMemoryLeaks();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="5-其它研究"><a href="#5-其它研究" class="headerlink" title="5 其它研究"></a>5 其它研究</h1><p>查看俄文作者的《Design Pattern with Modern C++》(2018)后发现，在上例的 func1 或者 func2 中有一种写法是保留 new 对象传参：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void sa::func1(User *u)&#123;</span><br><span class="line">    pu-&gt;setState(new sb());</span><br><span class="line">    delete this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过测试，发现这种写法在程序运行时会出现野指针导致崩溃，即需要使用的指针指向的对象已经释放。</p><p>并且，在 main 中，出现对 setState 的调用后，其 new 形式传参的内存泄漏时不能避免的。</p><p>另外，对于 CrtDumpMemoryLeaks() 的位置如果放置在 system 前，则会出现在 return 0 程序结束前，过早检查资源的情况。</p><p>最后，对于 main 中使用 shared_ptr<User>，后续测试其一直保持 use_count 保持为 1，导致 User 对象资源不释放，在程序结束前添加 pu.reset() 将其引用技术置为0，后续测试无内存泄漏问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1 引言&quot;&gt;&lt;/a&gt;1 引言&lt;/h1&gt;&lt;h2 id=&quot;1-1-写作背景&quot;&gt;&lt;a href=&quot;#1-1-写作背景&quot; class=&quot;headerlink&quot; title=&quot;1.1 写作背景&quot;&gt;&lt;/a&gt;1.1 写作背景&lt;/h2&gt;&lt;p&gt;我看的设计模式资料使用 C# 和 Java 实现，这两种语言不需要处理内存泄漏问题。后续发现按照资料仿写的 C++ 代码有内存泄漏的情况，于是尝试解决这个问题，对 C++ 有新的理解，故记录之。</summary>
    
    
    
    
    <category term="C++" scheme="https://hanxinle.github.io/tags/C/"/>
    
    <category term="设计模式" scheme="https://hanxinle.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL小记</title>
    <link href="https://hanxinle.github.io/2023/01/07/opengl-1/"/>
    <id>https://hanxinle.github.io/2023/01/07/opengl-1/</id>
    <published>2023-01-07T14:14:02.000Z</published>
    <updated>2023-03-22T10:22:32.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="写作目的"><a href="#写作目的" class="headerlink" title="写作目的"></a>写作目的</h2><p>记录 OpenGL 学习的环境准备工作，为了下一步学习扫清障碍。<br><span id="more"></span></p><h2 id="GitHub-Repo-of-Mine"><a href="#GitHub-Repo-of-Mine" class="headerlink" title="GitHub Repo of Mine"></a>GitHub Repo of Mine</h2><p><a href="https://github.com/hanxinle/opengl_stuff">hanxinle/opengl_stuff</a></p><h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learnopengl-cn.github.io/">1 learn-opengl-cn</a><br><a href="https://github.com/JoeyDeVries/LearnOpenGL">2 资料1对应的 GitHub</a><br>3 <a href="https://github.com/TheCherno/OpenGL">TheCherno OpenGL 教程整理的工程</a><br>4 计算机图像学（使用OpenGL和C++）【书籍】</p><!-- more -->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;h2 id=&quot;写作目的&quot;&gt;&lt;a href=&quot;#写作目的&quot; class=&quot;headerlink&quot; title=&quot;写作目的&quot;&gt;&lt;/a&gt;写作目的&lt;/h2&gt;&lt;p&gt;记录 OpenGL 学习的环境准备工作，为了下一步学习扫清障碍。&lt;br&gt;</summary>
    
    
    
    
    <category term="OpenGL" scheme="https://hanxinle.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC 库在 Windows 平台编译（支持 H.264）</title>
    <link href="https://hanxinle.github.io/2022/09/21/webrtc-build-on-windows/"/>
    <id>https://hanxinle.github.io/2022/09/21/webrtc-build-on-windows/</id>
    <published>2022-09-21T07:05:11.000Z</published>
    <updated>2023-06-22T06:26:24.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://avdancedu.com/2bafd6cf/">音视跳动李超老师的 WebRTC 编译博客</a></li><li><a href="https://webrtc.org/support/overview">WebRTC Support(官网)</a></li></ol><h1 id="编译环境准备"><a href="#编译环境准备" class="headerlink" title="编译环境准备"></a>编译环境准备</h1><p>根据官方文档：</p><p><a href="https://webrtc.googlesource.com/src/+/main/docs/native-code/development/">https://webrtc.googlesource.com/src/+/main/docs/native-code/development/</a></p><span id="more"></span><p>Windows 平台编译 WebRTC 与编译 Chromium 软件配置和操作大多一致，可以参考编译Chromium 文档编译 WebRTC，编译Chromium 文档的网址是：</p><p><a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/windows_build_instructions.md">https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/windows_build_instructions.md</a> 。</p><p>编译WebRTC需满足如下硬件要求：</p><ol><li>CPU型号为 intel；</li><li>内存大于等于 8G；</li><li>存放源码的硬盘是 NTFS 文件系统，容量建议大于等于100G。</li></ol><p>软件要求：</p><ul><li><p>Git</p><p>下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p></li><li><p>Visual Studio 2019</p><p>下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/vs/">https://visualstudio.microsoft.com/zh-hans/vs/</a> ,</p><p>其它版本可在名为“MSDN,i tell you”网站下载，网址是 <a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a> </p><p>必要组件：</p><p>选择 “Windows” 页面下的 .Net 桌面开发，使用 C++ 的桌面开发、通用 Windows 平台开发。</p><p>在 单个组件 标签下，找到并勾选 用于x86和x64的Visual C++ MFC、用于x86和X64的Visual C++ ATL、Clang/C2(实验)、带有Spectre缓解措施的Visual C++ ATL(x86/x64)、带有Spectre缓解措施的Visual C++ MFC(x86/x64)。</p></li><li><p>Windows sdk 和 Debugging Tools for Windows</p><p>Windows10 编译 WebRTC 所需的 Windows SDK 版本最低要求是10.0.19041.0，如果系统没有安装满足版本要求Windows SDK。请访问  <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk/">https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk/</a> 下载 .iso 文件，安装时选择 <strong>Debugging Tools for Windows</strong>。</p></li><li><p>depot tool</p></li></ul><p>depot_tool下载地址是</p><p><a href="https://storage.googleapis.com/chrome-infra/depot_tools.zip">https://storage.googleapis.com/chrome-infra/depot_tools.zip</a></p><p>若文件保存路径包含中文，请将depot_tools.zip移动到<strong>英文</strong>路径下，例如C:\bjm_tools\，右击depot_tools.zip,选择 解压到depot_tools（英文版解压软件命令是extract files to “depot_tools\”）.</p><p>将C:\bjm_tools\depot_tools添加到系统 path 路径，然后选定该项，单击 <strong>上移</strong> ，将其移动到顶部，缺少这一步会导致depot_tools命令与系统原有软件命令冲突时系统不会优先选择depot_tools工具所支持的命令，产生错误。</p><h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p>运行 x86 Native Tools Command Prompt for VS 2019 专业版，设置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 设置depot_tools使用本地VS进行编译</span><br><span class="line"><span class="built_in">set</span> DEPOT_TOOLS_WIN_TOOLCHAIN=0</span><br><span class="line">// 设置编译工具（GYP == Generate Your Projects）</span><br><span class="line"><span class="built_in">set</span> GYP_GENERATORS=ninja,msvs-ninja</span><br><span class="line">// 设置VS路径</span><br><span class="line"><span class="built_in">set</span> GYP_MSVS_OVERRIDE_PATH=C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise</span><br><span class="line">// 设置VS版本</span><br><span class="line"><span class="built_in">set</span> GYP_MSVS_VERSION=2019</span><br><span class="line">// 指明vs2019_install路径</span><br><span class="line"><span class="built_in">set</span> vs2019_install=C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是 vs2017，则设置以下变量（本人没有使用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设置depot_tools使用本地VS进行编译</span><br><span class="line"><span class="built_in">set</span> DEPOT_TOOLS_WIN_TOOLCHAIN=0</span><br><span class="line">// 设置编译工具（GYP == Generate Your Projects）</span><br><span class="line"><span class="built_in">set</span> GYP_GENERATORS=ninja,msvs-ninja</span><br><span class="line">// 设置VS路径</span><br><span class="line"><span class="built_in">set</span> GYP_MSVS_OVERRIDE_PATH=C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional</span><br><span class="line">// 设置VS版本</span><br><span class="line"><span class="built_in">set</span> GYP_MSVS_VERSION=2017</span><br><span class="line">// 指明vs2017_install路径</span><br><span class="line"><span class="built_in">set</span> vs2017_install=C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional</span><br></pre></td></tr></table></figure><p>因为网络问题，我在第一次启动 cmd 的时候设置了 Git 代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">&quot;127.0.0.1:1080&quot;</span></span><br><span class="line">git config --global https.proxy <span class="string">&quot;127.0.0.1:1080&quot;</span></span><br></pre></td></tr></table></figure><p>后来重启 cmd 又设置了系统代理（榨干ssr 最有一点流量）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=127.0.0.1:1080</span><br><span class="line"><span class="built_in">set</span> https_proxy=127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>设置后执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient</span><br></pre></td></tr></table></figure><p>该命令会安装其它所有编译 WebRTC源码所需要的、针对Windows平台特定的工具，例如 msysgit 和Python。</p><p>执行 gclient 命令后，输入命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">where</span> python</span><br></pre></td></tr></table></figure><p>确保 python.bat 出现在任何 python.exe 前再继续操作.</p><p>设置 git ，然后下载源码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxxxx@yy.com&quot;</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br><span class="line">git config --global core.filemode <span class="literal">false</span></span><br><span class="line">git config --global branch.autosetuprebase always</span><br></pre></td></tr></table></figure><p>下载源码过程是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建名为 webrtc-checkout 的文件夹</span><br><span class="line"><span class="built_in">mkdir</span> webrtc-checkout</span><br><span class="line">// 进入 webrtc-checkout</span><br><span class="line"><span class="built_in">cd</span> webrtc-checkout</span><br><span class="line">// 下载源码</span><br><span class="line">fetch --nohooks webrtc</span><br><span class="line">// 同步为最新版源码</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 src </span></span><br><span class="line"><span class="built_in">cd</span> src</span><br></pre></td></tr></table></figure><p>李超老师的博客提到如下编译流程：</p><p>首先，生成目录和编译库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> src</span><br><span class="line">$ gn gen out/Default</span><br><span class="line">$ ninja -C out/Default</span><br></pre></td></tr></table></figure><p>接着，再生成 vs 工程，用于调试学习</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen --ide=vs out\Default</span><br></pre></td></tr></table></figure><p>这个流程是我 2023 年 6 月份使用的，对 2021-05 和 2021-08 两个版本的源码都能编译。</p><p>在 2021 年，Default 是编译不过的。现在想当时的原因可能如下：</p><ol><li>编译环境变化，我现在把要设置的环境变量都写入到了系统环境变量中；</li><li>2021 生成的待编译文件有 —ide=vs 选项，对其有干扰；</li><li>现在使用了新的 Windows SDK 或者 VS2022 的关系；</li><li>depot_tool 的更新；</li><li>命令行的更换，我使用的是 develop prompt command for vs2019;</li></ol><p>2021 使用的生成 x86 debug with H.264 的 libwebrtc.lib 待编译文件命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/x86/vs2019ffmpeg_nolibcxx_nolld_notests --ide=vs2019 --args=<span class="string">&quot;target_cpu=\&quot;x86\&quot; is_debug = true  treat_warnings_as_errors = false</span></span><br><span class="line"><span class="string">use_custom_libcxx = false use_lld = false  rtc_use_h264 = true proprietary_codecs = true is_component_ffmpeg = true enable_iterator_debugging = true ffmpeg_branding = \&quot;Chrome\&quot; rtc_include_tests = false&quot;</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>out/x86/dh264ffmpeg</td><td>工程存放路径</td><td></td></tr><tr><td>—ide=vs2017</td><td>编译工程所用 IDE 工具</td><td></td></tr><tr><td>target_cpu=\”x86\”</td><td>webrtc.lib 是32位</td><td></td></tr><tr><td>target_winuwp_family=\”desktop\”</td><td>webrtc.lib用于Windows桌面程序</td><td>后续生成工程不再指定这个参数的值</td></tr><tr><td>is_debug=true</td><td>生成的静态库用于debug模式</td><td>默认debug模式，查看方法见表后正文</td></tr><tr><td>treat_warnings_as_errors=false</td><td>设置编译过程不将警告当作错误，避免中断编译过程</td><td>如果忘记关闭需要更改源码，详见后文</td></tr><tr><td>rtc_use_h264=true</td><td>支持H.264编码</td><td></td></tr><tr><td>proprietary_codecs=true</td><td>支持所有编解码方案开关开启</td><td></td></tr><tr><td>is_component_ffmpeg=true</td><td>编译ffmpeg模块用于支持H.264解码</td><td></td></tr><tr><td>ffmpeg_branding=\”Chrome\”</td><td>设置编译的ffmpeg多媒体播放设置适配Chrome系统</td></tr></tbody></table></div><p>上述命令耗时4336ms，Windows平台 H.264 解码用ffmpeg，ffmpeg解码需要用到Clang，is_clang选项默认为true，如果不用Clang，将不支持H.264解码。具体信息请访问 <a href="https://bugs.chromium.org/p/webrtc/issues/detail?id=9213">https://bugs.chromium.org/p/webrtc/issues/detail?id=9213</a> 。4.5 节会对详细说明这个网址涉及的内容。</p><p>补充一个创建 WebRTC工程后查看配置参数的命令，即在命令行中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn args out/x86/vs2019ffmpeg_nolibcxx_nolld_notests –list</span><br></pre></td></tr></table></figure><p>可以查看生成该工程可设置的所有参数，以及每个参数的当前值、默认值、该值的含义等信息。</p><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn args out/x86/vs2019ffmpeg_nolibcxx_nolld_notests –list=&lt;参数名&gt;</span><br></pre></td></tr></table></figure><p>可以查看特定参数的值。</p><p>编译 WebRTC 工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C out/x86/vs2019ffmpeg_nolibcxx_nolld_notests</span><br></pre></td></tr></table></figure><p>测试编译：</p><p>进入到生成目录 <em>out/x86/vs2019ffmpeg_nolibcxx_nolld_notests</em>，运行命令保存log并查看结果.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vidoe_engine_tests.exe &gt; video_engine_tests_log.txt</span><br></pre></td></tr></table></figure><h1 id="创建-peerconnection-工程测试编译的库"><a href="#创建-peerconnection-工程测试编译的库" class="headerlink" title="创建 peerconnection 工程测试编译的库"></a>创建 peerconnection 工程测试编译的库</h1><p>启动vs2019，打开资源管理器进入WebRTC 源码路径，在 /examples/server 下拷贝 data_socket.cc、data_socket.h、main.c、peer_channel.cc、peer_channel.h、utils.cc、utils.h 到 bjm_peerconnetcion_server 路径下，并且导入该工程；pc_client 示例程序所在路径是 src/examples/client，拷贝conductor.cc、conductor.h、defaults.cc、defaults.h、flag_defs.h、main.cc、main_wnd.cc、main_wnd.h、peer_connection_client.cc、peer_connection_server.h 到 pc_client 所在路径并且导入工程。</p><p><strong>对 server 配置 </strong>include 路径和库路径，在“链接器-输入”中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ws2_32.lib</span><br><span class="line">winmm.lib</span><br><span class="line">webrtc.lib</span><br><span class="line">my_webrtc.lib    </span><br></pre></td></tr></table></figure><p>PS: my_webrtc.lib 是自制.</p><p><strong>对 client ，配置</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ws2_32.lib</span><br><span class="line">winmm.lib</span><br><span class="line">strmiids.lib</span><br><span class="line">amstrmid.lib</span><br><span class="line">dmoguids.lib</span><br><span class="line">wmcodecdspuuid.lib</span><br><span class="line">crypt32.lib</span><br><span class="line">iphlpapi.lib</span><br><span class="line">secur32.lib</span><br><span class="line">rtc_json.lib</span><br><span class="line">msdmo.lib</span><br><span class="line">webrtc.lib</span><br><span class="line">ffmpeg.dll.lib</span><br><span class="line">my_webrtc.lib</span><br></pre></td></tr></table></figure><p>PS: my_webrtc.lib 是自制.</p><p>编译结束后，先启动 pc_server，再启动两个 pc_client ,单击 ”connect” 按钮，计算机上如果有两个摄像头，就可以互相看到对方。</p><p>PS: 我还保留了几个脚本工具用于测试环节提取 lib、头文件、将 obj 文件制作成为 lib。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>1、如果设置了 is_clang=false，会出现什么问题及解决方法是什么？</p><p>答：几个文件如 /modules/audio_processing/agc2/rnn_vad/features_extraction.cc</p><p>代码报错，提示不能对数据 窄化(narrowing) 操作。需要对该行报错的变量使用 static_cast&lt;窄化后的类型&gt; ，参考 <a href="https://en.cppreference.com/w/cpp/language/static_cast">https://en.cppreference.com/w/cpp/language/static_cast</a> 。</p><p>另有 TaskQueue 模块个别文件提示对象访问权限问题，根据报错信息打开源码，定位到报错的行，将 protected 改为 public。</p><p>最严重的问题是无法编译 ffmpeg，因为VS对C11支持不完全，提示找不到头文件，无法通过拷贝相应头文件到VS的include 目录解决这个问题。</p><p>2、如果不设置 treat_warnings_as_errors=false 会出现什么情况？如何解决？</p><p>答：在执行ninja –C &lt;工程路径&gt; 命令后，编译过程会被频繁打断。需要定位到警告信息产生的代码文件相应的行，在行的前后加入 #pragma warning (disable:&lt;警告编号&gt;)。</p><p>3、因为编译工程频繁更改代码，如何能统计自己更改了哪些代码以及做了何种更改？</p><p>答：命令行环境进入 webrtc-checkout/src 路径,执行 git diff 即可看到对源码的修改记录。建议用Visual Studio Code(下文称VSC)修改代码，修改后保存代码但不要退出VSC，若需要恢复到修改前的代码，切换到文件标签，不断按 Cril+Z,即可撤销修改，保存文件。再执行 git diff 即可看到源码无修改。</p><p>4、如何查看自己下载的WebRTC版本信息。</p><p>答：执行 gclient revinfo –a 。</p><p>5、这些参数是不是一成不变的？开发人员可以不了解直接采用 webrtc.lib？</p><p>答：每个版本控制生成工程的参数都有可能发生变化，本文档 v1.1版撰写时 v1.0版的一些参数已经不再被使用，由其它参数覆盖、替代或干脆移除某参数涉及的模块。第二个问题的答案为是，开发人员不需要了解具体参数的含义，这也是本文档的意义——节约时间。</p><p>6、H.264 编解码支持所依赖的 ffmpeg 编译及测试方案执行</p><div class="table-container"><table><thead><tr><th>WebRTC 生成工程参数</th><th>编译器</th><th>C++ 标准库版本</th><th>链接器</th><th>备注</th></tr></thead><tbody><tr><td>is_clang=false</td><td>MSVC cl.exe</td><td>MSVC lib</td><td>MSVC link.exe</td><td></td></tr><tr><td>is_clang=false  use_custom_libcxx=true  use_lld=true</td><td>Clang</td><td>Google custom  libcxx</td><td>lld</td><td>默认参数</td></tr><tr><td>is_clang=true  use_custom_libcxx=false</td><td>Clang</td><td>MSVC lib</td><td>lld</td><td></td></tr><tr><td>is_clang=true  use_custom_libcxx=false  use_lld=flase</td><td>Clang</td><td>MSVC lib</td><td>MSVC link.exe</td><td>本文档使用参数设置</td></tr></tbody></table></div><p>此处需要特别说明使用 H.264 编解码支持的x86 debug 版webrtc.lib 的项目属性配置方案。WebRTC 若要支持 H.264 解码，需要添加 ffmpeg 模块。编译此模块在Windows 系统需要Clang 编译器支持。因此在生成 webrtc.lib 工程时，相关参数要与上表的最后一列一致。</p><p>7、Windows 平台对 H.264 支持情况</p><p>2021年编译的时候我记录了如下信息，近期没有重新编译，进展情况自行查官方信息吧：</p><blockquote><p>WebRTC官方宣布 Windows 系统使用vs原生工具集则不支持 H.264 编解码，截至本文档撰写完毕这个 bug依旧没有解决。这是网址：</p><p><a href="https://bugs.chromium.org/p/webrtc/issues/detail?id=9213%23c13">https://bugs.chromium.org/p/webrtc/issues/detail?id=9213#c13</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://avdancedu.com/2bafd6cf/&quot;&gt;音视跳动李超老师的 WebRTC 编译博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webrtc.org/support/overview&quot;&gt;WebRTC Support(官网)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;编译环境准备&quot;&gt;&lt;a href=&quot;#编译环境准备&quot; class=&quot;headerlink&quot; title=&quot;编译环境准备&quot;&gt;&lt;/a&gt;编译环境准备&lt;/h1&gt;&lt;p&gt;根据官方文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://webrtc.googlesource.com/src/+/main/docs/native-code/development/&quot;&gt;https://webrtc.googlesource.com/src/+/main/docs/native-code/development/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="WebRTC" scheme="https://hanxinle.github.io/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>Vim 教程</title>
    <link href="https://hanxinle.github.io/2021/08/31/vim-note/"/>
    <id>https://hanxinle.github.io/2021/08/31/vim-note/</id>
    <published>2021-08-31T01:34:43.000Z</published>
    <updated>2023-01-16T16:11:54.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个性化的配置文件"><a href="#个性化的配置文件" class="headerlink" title="个性化的配置文件"></a>个性化的配置文件</h1><span id="more"></span><p>注释是一个双引号 “</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins manage</span><br><span class="line">call plug#begin()</span><br><span class="line">Plug &#x27;ycm-core/YouCompleteMe&#x27;</span><br><span class="line">call plug#end()</span><br><span class="line"></span><br><span class="line">packloadall</span><br><span class="line">silent! helptags ALL</span><br><span class="line"></span><br><span class="line">noremap ; :</span><br><span class="line">inoremap jk &lt;esc&gt;</span><br><span class="line">inoremap &#x27; &#x27;&#x27;&lt;esc&gt;i</span><br><span class="line">inoremap &quot; &quot;&quot;&lt;esc&gt;i</span><br><span class="line">inoremap ( ()&lt;esc&gt;i</span><br><span class="line">inoremap [ []&lt;esc&gt;i</span><br><span class="line">inoremap &#123; &#123;&#125;&lt;esc&gt;i</span><br><span class="line"></span><br><span class="line">noremap &lt;f1&gt; &lt;c-]&gt;</span><br><span class="line">noremap &lt;f2&gt; &lt;c-t&gt;</span><br><span class="line"></span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">set autoindent</span><br><span class="line">set expandtab</span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set backspace=2</span><br><span class="line"></span><br><span class="line">colorscheme murphy</span><br></pre></td></tr></table></figure><h1 id="版本恢复，错误处理"><a href="#版本恢复，错误处理" class="headerlink" title="版本恢复，错误处理"></a>版本恢复，错误处理</h1><p>.swap 文件，能够防止 ssh 中断而导致编写的文件内容丢失，若当前目录下存在 .swap 文件，书上说是可以设置跳转文件的路径的。</p><p>可选操作：</p><p><code>r</code> 恢复内容</p><p><code>d</code> 删除内容</p><p>设置 .swap 目录，防止多个 .swap 文件污染当前路径，在 .vimrc 中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set directory=$HOME/.vim/swap//   # 最后是两个斜杠 //</span><br></pre></td></tr></table></figure><h1 id="查找-跳转"><a href="#查找-跳转" class="headerlink" title="查找/跳转"></a>查找/跳转</h1><h2 id="文件内跳转"><a href="#文件内跳转" class="headerlink" title="文件内跳转"></a>文件内跳转</h2><div class="table-container"><table><thead><tr><th>按键</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td><code>hjkl</code></td><td>方向跳转</td><td>搭配数字操作更快，如 <code>22j</code>，向下跳转 22 行</td></tr><tr><td><code>&#123; / &#125;</code></td><td>段落跳转</td><td></td></tr><tr><td><code>( / )</code></td><td>句子开头、结尾</td><td></td></tr><tr><td><code>gg/G</code></td><td>文件尾/文件头</td><td></td></tr><tr><td><code>Ctrl +b / Ctrl +f</code></td><td>翻页</td><td></td></tr><tr><td><code>WBE/wbe</code></td><td>逐单词跳转</td><td>区别在于大写字母操作跳转力度大</td></tr><tr><td><code>f/F &lt;字母&gt;</code></td><td>同一行前后查找、跳转</td><td>向前/向后 跳转到匹配的第一个字母处</td></tr><tr><td><code>t/T &lt;字母&gt;</code></td><td>同一行前后查找、跳转</td><td>向前/向后 跳转到匹配的第一个字母的前一个字符处</td></tr><tr><td><code>d f &lt;字母&gt;</code></td><td>删除所有字符，到匹配的第一个字母</td></tr></tbody></table></div><ul><li>其它跳转操作 </li></ul><div class="table-container"><table><thead><tr><th>按键</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td><code>: /&lt;string &gt;</code></td><td><code>查找 &lt;string&gt;</code>，<code>n</code> 下个查找结果</td><td></td></tr><tr><td><code>*</code></td><td>同一个单词跳转</td><td></td></tr><tr><td><code>&#39;. (单引号，后句号)</code></td><td>上一次修改的行</td><td></td></tr><tr><td>`. (esc 下面的按键，后句号)</td><td>上一次修改的点</td></tr></tbody></table></div><h2 id="文件间跳转"><a href="#文件间跳转" class="headerlink" title="文件间跳转"></a>文件间跳转</h2><p>首先，未启动vim 时打开多个文件：</p><p><code>vim file1 file2 ...</code> 便可以打开所有想要打开的文件</p><p>若 vim 已经启动：</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:e file</span><br></pre></td></tr></table></figure><p>可以再打开一个文件，并且此时vim里会显示出file文件的内容。</p><p>同一个窗口中切换文件</p><p><code>Ctrl+6</code>     两文件间的切换，打开过两个文件才能切换</p><p><code>:bn</code>          下一个文件</p><p><code>:bp</code>          上一个文件</p><p>组合拳：</p><p><code>:ls</code>          列出打开的文件，带编号</p><p><code>:b1~n</code>      切换至第n个文件</p><h1 id="窗口切分、跳转、移动、调整大小"><a href="#窗口切分、跳转、移动、调整大小" class="headerlink" title="窗口切分、跳转、移动、调整大小"></a>窗口切分、跳转、移动、调整大小</h1><p><code>:sp</code>       垂直切分窗口</p><p><code>:vs</code>       水平切分窗口</p><p><code>C-w-r</code>   切换窗口；</p><p><code>C-w-c</code>   关闭窗口；</p><p><code>Ctrl+w+方向键</code>    切换到前／下／上／后一个窗格</p><p><code>Ctrl+w+h/j/k/l</code>   同上</p><p><code>Ctrl+ww</code>              依次向后切换到下一个窗格中</p><p>移动整个窗口内容方便查看：</p><p><code>Ctrl+w，HJKL</code>    将当前窗口移动到屏幕的 左/底/上/右</p><p>调整窗口大小的命令：</p><p><code>Ctrl+w，=</code>         所有窗口恢复到同样大小</p><p><code>:resize +&lt;数字&gt;</code>  高度增加 N 行</p><p><code>:resize -&lt;数字&gt;</code>  高度减小 N 行</p><p><code>:vertical resize +&lt;数字&gt;</code>    宽度增加 </p><p><code>:vertical resize -&lt;数字&gt;</code>    宽度减小</p><h1 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h1><p><code>c</code> 修改命令，如 <code>cw</code>  输入后就进入插入模式</p><p><code>o</code> 另起一行并进入插入模式</p><p><code>x</code> 删除一个字符</p><p><code>d</code> 剪切，当删除用</p><p><code>y</code> 复制</p><p><code>p</code> 粘贴</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="安装-vim"><a href="#安装-vim" class="headerlink" title="安装 vim"></a>安装 vim</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vim/vim.git</span><br><span class="line">cd vim/src</span><br><span class="line">./configure --enable-python3interp=yes --enable-cscope --enable-fontset --with-python3-config-dir=/usr/lib/python3.6/config-3.6m-x86_64-linux-gnu --with-python3-command=/usr/bin/python3.6</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="安装插件管理工具-vim-plug"><a href="#安装插件管理工具-vim-plug" class="headerlink" title="安装插件管理工具 vim-plug"></a>安装插件管理工具 vim-plug</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.github.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p>设置 .vimrc （注意：那两个# 不是注释），把要安装的插件名字放在单引号中，就复制GitHub 用户+ 仓库名就行，以 <code>YouCompleteMe</code> 为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin()</span><br><span class="line">Plug &#x27;ycm-core/YouCompleteMe&#x27;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>启动 vim，执行以下命令安装插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:PlugInstall </span><br></pre></td></tr></table></figure><h2 id="安装-YouCompleteMe"><a href="#安装-YouCompleteMe" class="headerlink" title="安装 YouCompleteMe"></a>安装 <code>YouCompleteMe</code></h2><p>对于 <code>YouCompleteMe</code>，安装一是要KeXue上网同步代码，二是要在里面执行下安装脚本 install.sh，这样在启动的时候才不会提示 ycmd 服务器没有启动的问题。</p><p>我在 Ubuntu18.08 LTS 上成功安装的，记录下过程。</p><p>升级安装gcc-8、g++-8，这个 apt 命令就搞定，还得执行个命令（<a href="https://blog.csdn.net/maoni99999/article/details/117378664">参考文献</a>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++-8</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 800 --slave /usr/bin/g++ g++ /usr/bin/g++-8</span><br></pre></td></tr></table></figure><p>然后进入到 <code>YouCompleteMe</code> 目录，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh install.sh        # 或者 ./install.sh  </span><br></pre></td></tr></table></figure><p>我执行 <code>./install.py --all</code> 中间会报错。</p><h2 id="读源码的工具-ctags"><a href="#读源码的工具-ctags" class="headerlink" title="读源码的工具 ctags"></a>读源码的工具 ctags</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ctags</span><br></pre></td></tr></table></figure><p>进入源码目录，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R</span><br></pre></td></tr></table></figure><p>用 vim 打开文件，想查询定义就按 <f1>，想看声明就按 <f2>，这两个键在 .vimrc 中有配置。取代了 <code>Crtl+t</code>/<code>Crtl+]</code>。</p><h1 id="在-Visual-Studio-等-IDE-中常用的设置"><a href="#在-Visual-Studio-等-IDE-中常用的设置" class="headerlink" title="在 Visual Studio 等 IDE 中常用的设置"></a>在 Visual Studio 等 IDE 中常用的设置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输入模式下：jk 代替 esc ，减少左手找案件的操作</span><br><span class="line">imap jk &lt;esc&gt;</span><br><span class="line"></span><br><span class="line"># 命令模式下，分号代替冒号，减少按 shift 的操作</span><br><span class="line">noremap ; :</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><p>[1] <a href="https://www.w3cschool.cn/vim/cjtr1pu3.html">w3cscchool 的教程</a></p><p>[2] <a href="https://www.imooc.com/learn/1129">慕课网 PegasusWang 的高质量免费教程</a></p><p>[3] <a href="https://zhuanlan.zhihu.com/p/113316942">Chrome插件Vimium使用教程</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;个性化的配置文件&quot;&gt;&lt;a href=&quot;#个性化的配置文件&quot; class=&quot;headerlink&quot; title=&quot;个性化的配置文件&quot;&gt;&lt;/a&gt;个性化的配置文件&lt;/h1&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://hanxinle.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>SRS 多种手段推拉流</title>
    <link href="https://hanxinle.github.io/2021/07/18/push-pull-stream-with-srs/"/>
    <id>https://hanxinle.github.io/2021/07/18/push-pull-stream-with-srs/</id>
    <published>2021-07-18T09:34:11.000Z</published>
    <updated>2022-12-28T13:34:21.212Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录几种与 SRS 之间推拉流的方法。<br><span id="more"></span></p><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>Docker 安装在 Windows 平台使用，这里备注两个使用时遇到的坑。一个是关于镜像保存，另一个是关于使用环境。容易使用的镜像因为对端口等有修改，所以每次使用后需要 commit，本地备份镜像的命令是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;image-id&gt; &lt;usr-defined-name&gt;</span><br></pre></td></tr></table></figure></p><p><usr-defined-name> 的建议的格式如下，不遵守格式会引发问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;usr-name&gt;/&lt;container-name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><br>我使用的名字是benjamin199/srs-4release:latest。<br>commit后的推送命令是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push benjamin199/srs-4release:latest</span><br></pre></td></tr></table></figure><br>推送时如果遇到如下报错：denied: requested access to the resource is denied.这就是因为镜像命名不规范而引发的错误，按照上述重新 commit 并且push可以解决这个问题。</p><p>docker在Windows上使用还有其它的一些坑，需要如下操作避开。<br>首先，按照docker的教程开启 Hyper-V、Linux子系统，后续会少麻烦。另外，要在应用商店搜索Ubuntu，我安装的是Ubuntu18（不收费）。<br>其次，如果启动docker提示 WSL无法启动，正确的解决方法是：按照老外的方法，卸载docker重新安装最新版，不要花费时间去重新设置docker，重新设置的方式行不通。<br>最后，无法加载镜像，docker无法启动，提示端口被占用，或者permission dennied, can not access 等。遇到这类情况，重启系统。如果还有这类问题，重新安装最新版docker。</p><p>docker部署后的推拉流命令分别如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i a.flv -vcodec copy -acodec copy -f flv -y rtmp://localhost/live/livestream</span><br><span class="line"></span><br><span class="line">ffplay -x 640 -y 480 rtmp://localhost/live/livestream</span><br></pre></td></tr></table></figure></p><h1 id="obs"><a href="#obs" class="headerlink" title="obs"></a>obs</h1><p>obs推拉流的坑在于密钥，实际上这是流的名字。使用obs的时候发现遇到一个问题，就是64位的软件会崩溃，因此操作使用32位。</p><h1 id="webrtc拉流"><a href="#webrtc拉流" class="headerlink" title="webrtc拉流"></a>webrtc拉流</h1><p>webrtc拉流可以使用的配置文件是rtc2rtmp.conf，把rtc_server中的candidata修改为云主机的外部ip，启动srs<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd srs/trunk</span><br><span class="line">./objs/srs -c conf/rtc2rtmp.conf</span><br></pre></td></tr></table></figure><br>启动srs后，本地需要推流以产生视频源，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i a.flv -vcodec copy -acodec copy -f flv -y rtmp://&lt;domain-name or ip&gt;/live/livestream</span><br></pre></td></tr></table></figure></p><h1 id="vlc"><a href="#vlc" class="headerlink" title="vlc"></a>vlc</h1><h2 id="vlc推流"><a href="#vlc推流" class="headerlink" title="vlc推流"></a>vlc推流</h2><p>菜单栏选择“媒体”-“流”，在“打开媒体”中选择“添加”添加媒体后点击“串流”，在“流输出”中设置rtsp后点击添加，端口6554不变，路径填上11，“流输出”的“激活转码”不选择，“串流所有基本流”也不选择，最后单击“流”。</p><h2 id="vlc拉流"><a href="#vlc拉流" class="headerlink" title="vlc拉流"></a>vlc拉流</h2><p>“媒体”——“打开网络串流”，如果是rtsp链接，可以填写如下rtsp://@:8554/11，其中@表示localhost，有些时候不添加可能会掉坑。</p><h1 id="FFmpeg推拉流"><a href="#FFmpeg推拉流" class="headerlink" title="FFmpeg推拉流"></a>FFmpeg推拉流</h1><p>获取摄像头名称：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -list_devices true -f dshow -i dummy</span><br></pre></td></tr></table></figure><br>摄像头推流命令，其中-s控制的是分辨率:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f dshow -i video=&quot;HD Webcam eMeet C960&quot; -vcodec libx264 -acodec copy -preset:v ultrafast -tune:v zerolatency -s 320x240 -f flv rtmp://&lt;ip or domain-name&gt;/live/livestream4</span><br></pre></td></tr></table></figure><br>文件推流命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i a.flv -vcodec copy -acodec copy -f flv -y rtmp://localhost/live/livestream</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章记录几种与 SRS 之间推拉流的方法。&lt;br&gt;</summary>
    
    
    
    
    <category term="SRS" scheme="https://hanxinle.github.io/tags/SRS/"/>
    
  </entry>
  
  <entry>
    <title>技术的简单性、累积性和组合性</title>
    <link href="https://hanxinle.github.io/2021/04/21/tech-talk/"/>
    <id>https://hanxinle.github.io/2021/04/21/tech-talk/</id>
    <published>2021-04-21T13:09:16.000Z</published>
    <updated>2022-12-16T15:23:09.432Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚在公众号“道哥的黑板报”，看了道哥最新的文章《如何看待一项技术：技术的本质》，文中的观点与我最近的感悟不谋而合。<span id="more"></span>但道哥思考得更深刻，得出的结论更加广博。</p><p>技术是简单的，不是复杂的。技术可以是新的生产力，也可以是新的体验。新的生产力的表现在于提升了生产效率，解决了问题，这是实践主义和实用主义者应当关心的内容。新的体验是理论研究的范畴，新的理论可以和生产力和解决问题没有关系，一种可能的情况是，提供了新的解决问题的思路，但暂时还没有体现出生产力。</p><p>技术很简单，道哥把技术的要素定义为：效率、成本、通用性、安全。其中效率是技术的主要价值目标，是一项新技术的出发点和根本。技术提升了效率，获得了新的能力。效率提升后，技术还需要进一步解决成本问题、通用性问题、安全问题，才能够扩大影响力和普及程度，形成生生不息的良性循环，进而改变世界。</p><p>道哥以工业革命为例，简述了技术诞生-改进-改变世界的全过程。纵观每一次影响世界的技术革命，我们几乎都能看到类似的生命周期，一项新技术诞生之初，先解决效率问题，再依次解决成本、通用性和安全问题，最后新技术走向普及。</p><p>并且道哥给出了技术人员可以怎么做：“通过「结构与组合」的方式。如果玩过一款叫「文明」的游戏，就会理解「科技树」这个概念。科技树非常形象的表达了，一项新的科技的诞生，是以其他已有科技为基础的。那么技术的创造方式就在于，通过不同现有技术之间的组合，搭建出一种新的结构，去解决一个特定的问题。因此从某种意义上来说，技术即解决方案。</p><p>这里面的玄妙之处，在于如何搭建出一种的结构。不同的人会选用不同的原子技术，来搭建出不同的结构。而结构搭建的方式，则体现了各种各样的奇思妙想，或者背后有着某种理论指导。这是充满了知识和创意的地方。也是通过这样的结构搭建，才有效解决了效率、成本、通用性和安全的问题。因此原子技术很重要，结构也很重要。技术的创造方式，就是结构与组合。瓦特在改进纽科门蒸汽机时，做的两项设计改进：分离式的冷凝器，以及曲柄传动，就是典型的结构与组合的再设计，进而解决了纽科门蒸汽机的成本和通用性的问题。</p><p>所有的技术扒开来看，都不神秘，都可以用很简单的原理和语言来描绘。”</p><p>我的经验是，在结构和组合前，一定要先建立一个整体的大局观，然后从最有正反馈的地方着手，即先跑起来，然后边积累边改进，改进的具体方法就是结构和组合的方式，即注意整体中短板部分的改进。</p><p>这样一点点积累，一个点只有组合为一个部件才是有生命力的，而改进的对象就是一个个部件。其次才是部件的组合，道哥讲述了结构性和组合性，我则发现最适合自己的是整体性-累积性，累积到部件再和道哥的理论研究结合起来，最大效率吸收旧技术的精华，同时催生新技术，迸发新技术的能量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;刚刚在公众号“道哥的黑板报”，看了道哥最新的文章《如何看待一项技术：技术的本质》，文中的观点与我最近的感悟不谋而合。</summary>
    
    
    
    
    <category term="技术思考" scheme="https://hanxinle.github.io/tags/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>《Linux 多线程服务端编程》阅读与实践（1）</title>
    <link href="https://hanxinle.github.io/2021/04/20/muduo-read-learn/"/>
    <id>https://hanxinle.github.io/2021/04/20/muduo-read-learn/</id>
    <published>2021-04-20T07:31:29.000Z</published>
    <updated>2022-12-15T14:13:32.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读小结"><a href="#阅读小结" class="headerlink" title="阅读小结"></a>阅读小结</h1><p>这篇博文是概括性的，目的在于理清作者的思路，作者有一套网络程序设计的教程，推荐学习。<br><span id="more"></span><br>前5章对 Linux 多线程做了细致的论述，对以下问题重点论述，解决。</p><p>线程安全的对象生命期，需要能标记其所持资源是否被占用的程序功能，直到提出 shared_ptr/weak_ptr 这一解决方案。</p><p>线程同步精要，给出精简有效的线程同步方案。对已经经过检验的经验要熟悉，不必求面面俱到。</p><p>多线程编程模型——one loop per thread，每个线程持有一个事件管理(Reactor),每个线程可以处理多个 I/O，这个做法和个人网盘项目的做法是一致的。我需要多写一些程序，体会这种方案的益处，知其然也知其所以然。</p><h1 id="实践：Libevent实现多线程-Reactor-线程池"><a href="#实践：Libevent实现多线程-Reactor-线程池" class="headerlink" title="实践：Libevent实现多线程 Reactor 线程池"></a>实践：Libevent实现多线程 Reactor 线程池</h1><p>该线程池的设计遵循one loop per thread思想，每个线程维护一个 Reactor。</p><p>该线程池的链接是：</p><p><a href="https://github.com/hanxinle/Xcpp/tree/main/src/libevent_learn/ch3_thread_pool">https://github.com/hanxinle/Xcpp/tree/main/src/libevent_learn/ch3_thread_pool</a></p><p>更进一步的实践是一个网盘应用，当前实现的网盘原型链接是</p><p><a href="https://github.com/hanxinle/XCloud-Disk">https://github.com/hanxinle/XCloud-Disk</a> 。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;阅读小结&quot;&gt;&lt;a href=&quot;#阅读小结&quot; class=&quot;headerlink&quot; title=&quot;阅读小结&quot;&gt;&lt;/a&gt;阅读小结&lt;/h1&gt;&lt;p&gt;这篇博文是概括性的，目的在于理清作者的思路，作者有一套网络程序设计的教程，推荐学习。&lt;br&gt;</summary>
    
    
    
    
    <category term="网络编程" scheme="https://hanxinle.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="多线程" scheme="https://hanxinle.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>借助 gcc 理解编译系统（compilation system）</title>
    <link href="https://hanxinle.github.io/2020/12/16/compliation-system-by-gcc/"/>
    <id>https://hanxinle.github.io/2020/12/16/compliation-system-by-gcc/</id>
    <published>2020-12-16T15:01:48.000Z</published>
    <updated>2022-12-16T15:22:20.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-编译系统-gcc-概述"><a href="#1-编译系统-gcc-概述" class="headerlink" title="1 编译系统(gcc)概述"></a>1 编译系统(gcc)概述</h2><span id="more"></span><p>通常，使用 gcc 编译程序 <code>gcc hello.c -o hello</code> 可以直接得到可执行的二进制文件 <em>hello</em>。然而，程序从源文件（文本）到可执行文件（二进制文件）要经历以下阶段:预处理，编译，汇编，链接，每个阶段处理后，都会得到新的文件，新的文件记录当前操作的信息，并且用于生成下一步操作。</p><p>编译系统由预处理器、编译器、汇编器和链接器组成，它将源程序文件“翻译”为二进制的可执行目标程序。编译系统工作流程及生成的文件如图所示。</p><p><img src="compilation_system_1.png" alt="compilation system"></p><p>在 gcc 中，每个阶段的操作见表1.</p><p><center>表1 编译系统命令</center></p><style>.tablelines table, .tablelines td, .tablelines th {        border: 1px solid black;        }</style><div class="table-container"><table><thead><tr><th>操作</th><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>预处理</td><td><code>gcc -E</code></td><td>-E -DXXX 定义XXX</td></tr><tr><td>编译</td><td>gcc -S</td><td>生成汇编文件</td></tr><tr><td>汇编</td><td>gcc -c</td><td>生成机器码</td></tr><tr><td>链接</td><td>gcc</td><td>生成可执行文件</td></tr></tbody></table></div><p>{: .tablelines}</p><h2 id="2-编译系统-gcc-详述"><a href="#2-编译系统-gcc-详述" class="headerlink" title="2 编译系统(gcc)详述"></a>2 编译系统(gcc)详述</h2><p><em>f_sum.h</em> 的内容是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><em>hello.c</em> 的内容是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;f_sum.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> var_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;makefile OK!\n&quot;</span>);</span><br><span class="line">    var_sum = f_sum(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Sum is %d\n&quot;</span>,var_sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-源程序"><a href="#2-1-源程序" class="headerlink" title="2.1 源程序"></a>2.1 源程序</h3><p>利用 <em>hexdump</em> 命令可以查看源程序对应的 ASCII 码（以及对应程序源码）。</p><figure class="highlight plaintext"><figcaption><span>-C  hello.c``` 输出如下：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>00000000  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include <stdio.|00000010  68 3e 0a 23 69 6e 63 6c  75 64 65 20 22 66 5f 73  |h>.#include “f_s|<br>00000020  75 6d 2e 68 22 0a 0a 2f  2f 69 6e 74 20 66 5f 73  |um.h”..//int f_s|<br>00000030  75 6d 28 69 6e 74 20 61  2c 69 6e 74 20 62 29 3b  |um(int a,int b);|<br>00000040  0a 0a 69 6e 74 20 6d 61  69 6e 28 29 20 7b 0a 20  |..int main() {. |<br>00000050  20 20 20 69 6e 74 20 76  61 72 5f 73 75 6d 20 3d  |   int var_sum =|<br>00000060  20 30 3b 0a 20 20 20 20  70 72 69 6e 74 66 20 28  | 0;.    printf (|<br>00000070  22 6d 61 6b 65 66 69 6c  65 20 4f 4b 21 5c 6e 22  |”makefile OK!\n”|<br>00000080  29 3b 0a 20 20 20 20 76  61 72 5f 73 75 6d 20 3d  |);.    var_sum =|<br>00000090  20 66 5f 73 75 6d 28 32  2c 33 29 3b 0a 20 20 20  | f_sum(2,3);.   |<br>000000a0  20 70 72 69 6e 74 66 20  28 22 53 75 6d 20 69 73  | printf (“Sum is|<br>000000b0  20 25 64 5c 6e 22 2c 76  61 72 5f 73 75 6d 29 3b  | %d\n”,var_sum);|<br>000000c0  0a 20 20 20 20 72 65 74  75 72 6e 20 30 3b 0a 7d  |.    return 0;.}|<br>*<br>000000d1<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">可以看到，*hello.c* 的长度是 0xd1 字节。</span><br><span class="line"></span><br><span class="line">### 2.2 预处理阶段</span><br><span class="line"></span><br><span class="line">预处理阶段完成的工作有，头文件的插入、宏定义的展开及条件编译的处理。</span><br><span class="line"></span><br><span class="line">预处理的命令是 ```gcc -E```，执行如下命令,</span><br><span class="line"></span><br><span class="line"> ```gcc -E hello.c -o hello.i```</span><br><span class="line"></span><br><span class="line">查看 ```hello.i``` 的内容如下(不加上 -o hello.i 就会直接显示预处理结果，和下面相同)：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>(省略大量 stdio.h 的代码)<br>……</p><h1 id="868-“-usr-include-stdio-h”-3-4"><a href="#868-“-usr-include-stdio-h”-3-4" class="headerlink" title="868 “/usr/include/stdio.h” 3 4"></a>868 “/usr/include/stdio.h” 3 4</h1><h1 id="2-“hello-c”-2"><a href="#2-“hello-c”-2" class="headerlink" title="2 “hello.c” 2"></a>2 “hello.c” 2</h1><h1 id="1-“f-sum-h”-1"><a href="#1-“f-sum-h”-1" class="headerlink" title="1 “f_sum.h” 1"></a>1 “f_sum.h” 1</h1><h1 id="1-“f-sum-h”"><a href="#1-“f-sum-h”" class="headerlink" title="1 “f_sum.h”"></a>1 “f_sum.h”</h1><p>int f_sum(int a, int b) {<br>    return a+b;<br>}</p><h1 id="3-“hello-c”-2"><a href="#3-“hello-c”-2" class="headerlink" title="3 “hello.c” 2"></a>3 “hello.c” 2</h1><p>int main() {<br>    int var_sum = 0;<br>    printf (“makefile OK!\n”);<br>    var_sum = f_sum(2,3);<br>    printf (“Sum is %d\n”,var_sum);<br>    return 0;<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">观察宏定义展开及条件条件编译的源程序 ```test_gcc_e.c``` 的内容如下：</span><br></pre></td></tr></table></figure></p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="define-LENGTH-1024"><a href="#define-LENGTH-1024" class="headerlink" title="define LENGTH 1024"></a>define LENGTH 1024</h1><p>int main(void) {</p><h1 id="ifdef-TEST"><a href="#ifdef-TEST" class="headerlink" title="ifdef TEST"></a>ifdef TEST</h1><pre><code>printf (&quot;TEST Defined!\n &quot;);</code></pre><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><pre><code>printf (&quot;Value of LENGTH is %d\n&quot;,1024);return 0;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行 ```gcc -E test_gcc_e.c``` 得到：</span><br></pre></td></tr></table></figure><p>……(省略的代码)<br>int main(void) {<br>    printf (“Value of LENGTH is %d\n”,1024);</p><pre><code>return 0;</code></pre><p>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以看到 LENGTH 的 值经过预处理已经被替换为 1024。</span><br><span class="line"></span><br><span class="line">执行 ```gcc -E -DTEST```</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>int main(void) {</p><pre><code>printf (&quot;TEST Defined!\n &quot;); //TEST definedprintf (&quot;Value of LENGTH is %d\n&quot;,1024);return 0;</code></pre><p>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.3 编译阶段</span><br><span class="line"></span><br><span class="line">编译得到汇编程序，文件后缀为 *.s*，命令是 ```gcc -S```，执行 ```gcc -S hello.i``` 或者 ```gcc -S hello.c``` ，有：</span><br></pre></td></tr></table></figure></p><pre><code>    .file   &quot;hello.c&quot;    .text    .globl  f_sum    .type   f_sum, @function</code></pre><p>f_sum:<br>.LFB0:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    %edi, -4(%rbp)<br>        movl    %esi, -8(%rbp)<br>        movl    -4(%rbp), %edx<br>        movl    -8(%rbp), %eax<br>        addl    %edx, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   f_sum, .-f_sum<br>        .section        .rodata<br>.LC0:<br>        .string “makefile OK!”<br>.LC1:<br>        .string “Sum is %d\n”<br>        .text<br>        .globl  main<br>        .type   main, @function<br>main:<br>.LFB1:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        subq    $16, %rsp<br>        movl    $0, -4(%rbp)<br>        leaq    .LC0(%rip), %rdi<br>        call    puts@PLT<br>        movl    $3, %esi<br>        movl    $2, %edi<br>        call    f_sum<br>        movl    %eax, -4(%rbp)<br>        movl    -4(%rbp), %eax<br>        movl    %eax, %esi<br>        leaq    .LC1(%rip), %rdi<br>        movl    $0, %eax<br>        call    printf@PLT<br>        movl    $0, %eax<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE1:<br>        .size   main, .-main<br>        .ident  “GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0”<br>        .section        .note.GNU-stack,””,@progbits</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序主要分为 LFB0、LFB1 两个模块，分别是 f_sum.h 和 main.c 对应的汇编代码。</span><br><span class="line">其中 ```call    puts@PLT``` 调用的是 *printf* 函数，</span><br></pre></td></tr></table></figure><p>movl    $3, %esi<br>movl    $2, %edi<br>call    f_sum<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```call f_sum``` 调用的是 *f_sum* 函数，f_sum 中执行 addl 是求和运算。</span><br><span class="line">### 2.4 汇编阶段</span><br><span class="line"></span><br><span class="line">汇编阶段用汇编文件生成机器码，命令是 ```gcc -c ```。</span><br><span class="line"></span><br><span class="line">执行 ```gcc -c hello.s``` 得到 *hello.o*，执行 ```objdump -d hello.o``` 查看 *hello.o* 内容，</span><br></pre></td></tr></table></figure><br>hello.o：     文件格式 elf64-x86-64<br>Disassembly of section .text:</p><p>0000000000000000 <f_sum>:<br>   0:   55                      push   %rbp<br>   1:   48 89 e5                mov    %rsp,%rbp<br>   4:   89 7d fc                mov    %edi,-0x4(%rbp)<br>   7:   89 75 f8                mov    %esi,-0x8(%rbp)<br>   a:   8b 55 fc                mov    -0x4(%rbp),%edx<br>   d:   8b 45 f8                mov    -0x8(%rbp),%eax<br>  10:   01 d0                   add    %edx,%eax<br>  12:   5d                      pop    %rbp<br>  13:   c3                      retq</p><p>0000000000000014 <main>:<br>  14:   55                      push   %rbp<br>  15:   48 89 e5                mov    %rsp,%rbp<br>  18:   48 83 ec 10             sub    $0x10,%rsp<br>  1c:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)<br>  23:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 2a <main+0x16><br>  2a:   e8 00 00 00 00          callq  2f <main+0x1b><br>  2f:   be 03 00 00 00          mov    $0x3,%esi<br>  34:   bf 02 00 00 00          mov    $0x2,%edi<br>  39:   e8 00 00 00 00          callq  3e <main+0x2a><br>  3e:   89 45 fc                mov    %eax,-0x4(%rbp)<br>  41:   8b 45 fc                mov    -0x4(%rbp),%eax<br>  44:   89 c6                   mov    %eax,%esi<br>  46:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 4d <main+0x39><br>  4d:   b8 00 00 00 00          mov    $0x0,%eax<br>  52:   e8 00 00 00 00          callq  57 <main+0x43><br>  57:   b8 00 00 00 00          mov    $0x0,%eax<br>  5c:   c9                      leaveq<br>  5d:   c3                      retq<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一行指明目标平台，第二行指出是对机器码的反汇编文件，尖括号 &lt;&gt; 指明对哪个函数的反汇编，左边是机器码，右边是对应的汇编带啊吗。</span><br><span class="line"></span><br><span class="line">可以看到在调用函数的语句处，*callq* 指令的地址是 00 00 00 00，并没有填入有效的函数地址，经过链接才填入，此时的文件被称作可重定位目标文件，即各节代码都是以 0 地址作为开始，但是将它们链接在一起时，会放入不重叠的地址空间。</span><br><span class="line"></span><br><span class="line">### 2.5 链接阶段</span><br><span class="line"></span><br><span class="line">汇编阶段生成的目标机器码并没有填入调用函数的地址，链接阶段完成这一过程。链接阶段为各个模块的目标代码在程序空间（运行时进程空间、虚拟地址）中指定它们独立的、不重叠的位置和区间，这个过程叫做“布局”。对未确定的目标地址，如汇编阶段 *callq* 指令全 0 的地址，需要用布局后的对应的函数地址填充，这个过程称作“重定位”。执行 ```gcc hello.o -o hello``` 生成文件 *hello*，然后执行 ```objdump -d hello``` ，显示如下：</span><br></pre></td></tr></table></figure><br>000000000000069e <main>:<br> 69e:   55                      push   %rbp<br> 69f:   48 89 e5                mov    %rsp,%rbp<br> 6a2:   48 83 ec 10             sub    $0x10,%rsp<br> 6a6:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)<br> 6ad:   48 8d 3d c0 00 00 00    lea    0xc0(%rip),%rdi        # 774 <_IO_stdin_used+0x4><br> 6b4:   e8 97 fe ff ff          callq  550 <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x70;&#x75;&#x74;&#115;&#64;&#x70;&#108;&#x74;">&#x70;&#x75;&#x74;&#115;&#64;&#x70;&#108;&#x74;</a><br> 6b9:   be 03 00 00 00          mov    $0x3,%esi<br> 6be:   bf 02 00 00 00          mov    $0x2,%edi<br> 6c3:   e8 c2 ff ff ff          callq  68a <f_sum><br> 6c8:   89 45 fc                mov    %eax,-0x4(%rbp)<br> 6cb:   8b 45 fc                mov    -0x4(%rbp),%eax<br> 6ce:   89 c6                   mov    %eax,%esi<br> 6d0:   48 8d 3d aa 00 00 00    lea    0xaa(%rip),%rdi        # 781 <_IO_stdin_used+0x11><br> 6d7:   b8 00 00 00 00          mov    $0x0,%eax<br> 6dc:   e8 7f fe ff ff          callq  560 <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#112;&#114;&#105;&#110;&#x74;&#102;&#x40;&#x70;&#x6c;&#x74;">&#112;&#114;&#105;&#110;&#x74;&#102;&#x40;&#x70;&#x6c;&#x74;</a><br> 6e1:   b8 00 00 00 00          mov    $0x0,%eax<br> 6e6:   c9                      leaveq<br> 6e7:   c3                      retq<br> 6e8:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)<br> 6ef:   00</p><p>```</p><p>将 0x550、0x68a 分别填入 <em>callq</em> 地址，对 <em>f_sum</em>调用使用了静态链接，在程序创建后就已经确定。查看 <em>printf</em> 调用地址发现该地址位于 <em>section.plt</em>，并且对应一条跳转指令，这涉及动态链接概念，创建可执行文件时仍不确定 <em>printf</em> 所在位置，需要运行时才能确定函数地址，当前暂时只想一个辅助代码的位置 <em>.plt</em> 处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-编译系统-gcc-概述&quot;&gt;&lt;a href=&quot;#1-编译系统-gcc-概述&quot; class=&quot;headerlink&quot; title=&quot;1 编译系统(gcc)概述&quot;&gt;&lt;/a&gt;1 编译系统(gcc)概述&lt;/h2&gt;</summary>
    
    
    
    
    <category term="gcc/gdb" scheme="https://hanxinle.github.io/tags/gcc-gdb/"/>
    
  </entry>
  
</feed>
